<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kc&#39;s Blog</title>
  
  <subtitle>(⊙.⊙)</subtitle>
  <link href="https://keyc.top/atom.xml" rel="self"/>
  
  <link href="https://keyc.top/"/>
  <updated>2026-02-11T10:09:20.564Z</updated>
  <id>https://keyc.top/</id>
  
  <author>
    <name>KingCide</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用Claude Code给博客加碎碎念页面</title>
    <link href="https://keyc.top/%E7%94%A8Claude-Code%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E7%A2%8E%E7%A2%8E%E5%BF%B5%E9%A1%B5%E9%9D%A2/"/>
    <id>https://keyc.top/%E7%94%A8Claude-Code%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E7%A2%8E%E7%A2%8E%E5%BF%B5%E9%A1%B5%E9%9D%A2/</id>
    <published>2026-02-11T09:00:00.000Z</published>
    <updated>2026-02-11T10:09:20.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一直想在博客里加一个随手记录想法的地方，不用写成完整的文章，也不需要标题和分类，就是随便说两句。用 Claude Code 从需求到上线大概十分钟搞定了。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>博客写文章的门槛太高了，有时候只是一句感想、一个灵感，专门开一篇 post 太重了。我想要的是一个类似微博/说说的轻量页面：</p><ul><li>纯静态，不依赖后端，跟博客一起部署到 GitHub Pages</li><li>数据用 JSON 文件存在本地，方便 git 管理</li><li>独立页面，不经过 Hexo 主题渲染</li><li>命令行一行命令就能添加新想法</li></ul><h2 id="用-Claude-Code-实现"><a href="#用-Claude-Code-实现" class="headerlink" title="用 Claude Code 实现"></a>用 Claude Code 实现</h2><p><a href="https://docs.anthropic.com/en/docs/claude-code/overview">Claude Code</a> 是 Anthropic 的命令行 AI 工具，可以直接在终端里对话，它能读写文件、执行命令、理解项目上下文。</p><p>整个过程是这样的：我把需求描述给 Claude Code，包括文件结构、每个文件的职责、需要修改哪些配置，它会先给出实施方案，确认后直接在项目里创建和修改文件。</p><p>最终的文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source/thoughts/</span><br><span class="line">├── index.html     ← 独立页面（skip_render，不经 Hexo 处理）</span><br><span class="line">├── style.css      ← 时间线样式</span><br><span class="line">├── app.js         ← 读取 data.json 渲染</span><br><span class="line">└── data.json      ← 想法数据</span><br><span class="line"></span><br><span class="line">tools/</span><br><span class="line">└── thought.js     ← 快捷添加脚本</span><br></pre></td></tr></table></figure><h3 id="关键配置"><a href="#关键配置" class="headerlink" title="关键配置"></a>关键配置</h3><p>Hexo 的 <code>_config.yml</code> 里加一行，让 thoughts 目录不被 Hexo 处理，原样复制到输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">thoughts/**</span></span><br></pre></td></tr></table></figure><p>主题的 <code>_config.yml</code> 里加导航入口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">thoughts:</span> <span class="string">/thoughts/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-comment</span></span><br></pre></td></tr></table></figure><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p><code>data.json</code> 就是一个数组，新的在前面：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;想法内容&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2026-02-11T17:00:00+08:00&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>页面用 <code>fetch(&#39;./data.json&#39;)</code> 加载数据，渲染成左侧竖线加圆点的时间线布局。时间显示做了智能处理：今年的省略年份，跨年的显示完整日期。</p><h3 id="命令行添加"><a href="#命令行添加" class="headerlink" title="命令行添加"></a>命令行添加</h3><p>写了一个 Node 脚本，一行命令添加新想法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node tools/thought.js <span class="string">&quot;今天天气真好&quot;</span></span><br></pre></td></tr></table></figure><p>它会读取 <code>data.json</code>，在数组头部插入新条目并自动生成时间戳，写回文件。输出确认信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">已添加: &quot;今天天气真好&quot;</span><br><span class="line">时间: 2026-02-11T17:06:08+08:00</span><br><span class="line">共 3 条碎碎念</span><br></pre></td></tr></table></figure><blockquote><p>注意脚本放在 <code>tools/</code> 而不是 <code>scripts/</code> 目录——Hexo 会自动加载 <code>scripts/</code> 下的所有 JS 文件作为插件执行，放在那里会报语法错误。</p></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>和平时发博客一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><p><code>source/thoughts/</code> 会原样复制到 <code>public/thoughts/</code>，部署后访问 <a href="https://keyc.top/thoughts/">keyc.top/thoughts/</a> 即可。</p><h2 id="Claude-Code-工作流"><a href="#Claude-Code-工作流" class="headerlink" title="Claude Code 工作流"></a>Claude Code 工作流</h2><p>简单记录下 Claude Code 的使用方式，以后类似的开发任务都可以这样做。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @anthropic-ai/claude-code</span><br></pre></td></tr></table></figure><p>需要 Node.js 18+，安装后在终端输入 <code>claude</code> 启动。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在项目根目录下启动，它会自动读取项目上下文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/BLOG/KingCide</span><br><span class="line">claude</span><br></pre></td></tr></table></figure><p>进入交互界面后，直接用自然语言描述需求。它能：</p><ul><li>读取和修改项目中的文件</li><li>执行 shell 命令（需要确认）</li><li>理解项目结构和依赖关系</li><li>一次性创建多个文件</li></ul><h3 id="实际对话示例"><a href="#实际对话示例" class="headerlink" title="实际对话示例"></a>实际对话示例</h3><p>我的做法是先进入 plan 模式，让它分析需求、列出要修改的文件和步骤，确认方案没问题后再让它执行。这样可以避免它自作主张改错东西。</p><p>关键命令：</p><ul><li><code>/help</code>：查看帮助</li><li>直接输入需求描述，它会分析并提出方案</li><li>确认方案后它自动创建/修改文件</li><li>可以让它直接执行 <code>hexo generate</code>、<code>hexo deploy</code> 等命令</li></ul><h3 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h3><ul><li>博客功能开发（新页面、新插件、配置修改）</li><li>批量文件操作</li><li>调试和排查问题（它能读报错信息并给出修复）</li><li>脚本编写</li></ul><p>对于这种”需求明确、涉及多个文件、有一定重复性”的任务，AI 工具的效率提升是很明显的。而且它对 Hexo 这类常见框架的理解很到位，不需要过多解释背景。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>目前这个方案只能在电脑上添加想法。如果以后想在手机上也能发，可以：</p><ul><li>把 <code>data.json</code> 的读写迁移到 GitHub API 或 Cloudflare Workers</li><li><code>app.js</code> 改为从 API 获取数据</li><li>页面本身不需要改动</li></ul><p>先这样用着，够用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直想在博客里加一个随手记录想法的地方，不用写成完整的文章，也不需要标题和分类，就是随便说两句。用 Claude Code 从需求到上线大概十分钟搞定了。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="Hexo" scheme="https://keyc.top/tags/Hexo/"/>
    
    <category term="JavaScript" scheme="https://keyc.top/tags/JavaScript/"/>
    
    <category term="Claude Code" scheme="https://keyc.top/tags/Claude-Code/"/>
    
  </entry>
  
  <entry>
    <title>当你有一个域名</title>
    <link href="https://keyc.top/%E5%BD%93%E4%BD%A0%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D/"/>
    <id>https://keyc.top/%E5%BD%93%E4%BD%A0%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D/</id>
    <published>2026-01-30T20:08:33.000Z</published>
    <updated>2026-02-01T08:52:47.723Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>正式购买了10年的域名 keyc.top ， 庆祝它成为我在互联网的一个锚点。</p><span id="more"></span><h2 id="更改博客访问地址"><a href="#更改博客访问地址" class="headerlink" title="更改博客访问地址"></a>更改博客访问地址</h2><h3 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h3><p>将原本 <a href="">kingcide.github.io</a> 访问的网站，改为通过 <a href="">keyc.top</a> 和 <a href="http://www.keyc.top/">www.keyc.top</a> 访问</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20260131041025560.png" alt="image-20260131041025560" style="zoom:50%;" /><h3 id="Cloudflare-配置"><a href="#Cloudflare-配置" class="headerlink" title="Cloudflare 配置"></a>Cloudflare 配置</h3><p>cloudflare里必须把ssl设置为Full模式，不能是Flexible，否则页面会显示重定向次数过多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">浏览器 → HTTPS 到 Cloudflare</span><br><span class="line">Cloudflare → HTTP 到 GitHub</span><br><span class="line">GitHub 重定向回 HTTPS</span><br><span class="line">Cloudflare 再转换 → 循环</span><br></pre></td></tr></table></figure><h4 id="Full-Flexible-Strict区别"><a href="#Full-Flexible-Strict区别" class="headerlink" title="Full/Flexible/Strict区别"></a>Full/Flexible/Strict区别</h4><p>Flexible（灵活模式）：浏览器 → HTTPS → Cloudflare → HTTP → 服务器（服务器没有HTTPS时使用）</p><p><strong>Full（完全模式）</strong>：浏览器 → HTTPS → Cloudflare → HTTPS → 服务器 （比较安全，在服务器有 HTTPS 支持时，可以是自签证书，我目前使用这种）</p><p>Full (Strict)（严格模式）：浏览器 → HTTPS → Cloudflare → HTTPS → 服务器（证书必须有效，不接受自签证书，最安全）</p><h4 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@   A    185.199.108.153</span><br><span class="line">@   A    185.199.109.153</span><br><span class="line">@   A    185.199.110.153</span><br><span class="line">@   A    185.199.111.153</span><br><span class="line">www CNAME kingcide.github.io</span><br></pre></td></tr></table></figure><p>实际上也可以按照github官方建议，添加ipv6的解析。</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20260131051248160.png" alt="image-20260131051248160" style="zoom:50%;" /><p>Proxy（橙云）是流量经过 Cloudflare 网络（DDoS 防护，<strong>访问统计</strong>），DNS Only（灰云）是直接连接到源站（访问者直接连接到服务器，Cloudflare 不缓存、不防护、不解析 HTTP）。我最后是开了Proxy。</p><h3 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h3><p>在 Hexo 根目录下新建：<code>source/CNAME</code>，内容：<code>keyc.top</code>，</p><p>这样每次部署都会自动带上这个文件，不会再丢失自定义域名配置。</p><h2 id="让谷歌搜索收录本站文章"><a href="#让谷歌搜索收录本站文章" class="headerlink" title="让谷歌搜索收录本站文章"></a>让谷歌搜索收录本站文章</h2><p>托管在github的静态网站，也是可以被Google 抓取。</p><p>让GPT教我一步步实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">教我如何正确在 Google Search Console 里提交我自定义域名的网站、sitemap 和请求抓取文章！😊</span><br></pre></td></tr></table></figure><ol><li>打开 Google Search Console 并添加你的网站</li><li>验证你对域名的所有权</li><li>提交 Sitemap（站点地图）：按照 Hexo Sitemap 插件配置好，生成的 sitemap 通常在<code>https://keyc.top/sitemap.xml</code></li><li>请求单个文章抓取（快速收录）：输入某篇文章的完整 URL</li></ol><h3 id="本地修改-1"><a href="#本地修改-1" class="headerlink" title="本地修改"></a>本地修改</h3><ol><li>安装 Hexo Sitemap 插件 <code>npm install hexo-generator-sitemap --save</code><br>在 Hexo 根目录的 <code>_config.yml</code> 里加入：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure><ol start="2"><li>修改 Hexo <code>_config.yml</code> 的 <code>url</code> 为新的域名 <code>https://keyc.top</code>，否则sitemap里的都是github的链接，谷歌无法识别。</li><li>在 <code>source/</code> 目录下新建：robots.txt，填入内容允许所有</li><li>将 Hexo 默认的 URL 从<code>*permalink: :year/:month/:day/:title/*</code>改为<code>permalink: :title/</code>，结构更简洁，更利于 SEO。</li></ol><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20260201165227142.png" alt="image-20260201165227142" style="zoom:40%;" /><h2 id="为博客增加RSS订阅功能"><a href="#为博客增加RSS订阅功能" class="headerlink" title="为博客增加RSS订阅功能"></a>为博客增加RSS订阅功能</h2><ol><li><p><code>npm install hexo-generator-feed --save</code></p></li><li><p>配置 <code>_config.yml</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span>      <span class="comment"># 生成的格式（常用 atom 或 rss2）</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span>  <span class="comment"># 生成的 RSS 文件名</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span>       <span class="comment"># feed 中包含的文章数量，设置 0 或 false 显示全部</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span>   <span class="comment"># 是否在 RSS 中包含全文</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span> <span class="comment"># 按日期倒序排列</span></span><br></pre></td></tr></table></figure></li><li><p>在主题config中配置图标和链接<code>RSS: /atom.xml || fa fa-rss</code></p></li><li><p><code>https://keyc.top/atom.xml</code>查看是否生效</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;正式购买了10年的域名 keyc.top ， 庆祝它成为我在互联网的一个锚点。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="网络" scheme="https://keyc.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="DNS" scheme="https://keyc.top/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>Cloudflare玩法大全</title>
    <link href="https://keyc.top/Cloudflare%E7%8E%A9%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
    <id>https://keyc.top/Cloudflare%E7%8E%A9%E6%B3%95%E5%A4%A7%E5%85%A8/</id>
    <published>2026-01-30T16:59:15.000Z</published>
    <updated>2026-02-01T09:22:29.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Cloudflare Workers是我们最容易访问到的serverless服务，可以进行很多有意思的尝试，从尝试免费服务开始，学习它相关的技术。</p><span id="more"></span><h2 id="基于-Cloudflare-Workers-为静态页面做-KV-存储"><a href="#基于-Cloudflare-Workers-为静态页面做-KV-存储" class="headerlink" title="基于 Cloudflare Workers 为静态页面做 KV 存储"></a>基于 Cloudflare Workers 为静态页面做 KV 存储</h2><p>记录每个访客的IP，</p><p><a href="https://keyc.top/__dash?key=ABC">https://keyc.top/__dash?key=ABC</a></p><p><a href="https://keyc-analytics.1659057796.workers.dev/__dash?key=ABC">https://keyc-analytics.1659057796.workers.dev/__dash?key=ABC</a></p><h3 id="V1"><a href="#V1" class="headerlink" title="V1"></a>V1</h3><p>目标对象是任何<strong>托管域名DNS服务在cloudflare</strong>的用户，理论上希望能够统计根域名和子域名的多个服务，覆盖cloudflare的基本数据统计，但数据粒度更细，维度更全。</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20260201045821284.png" alt="image-20260201045821284" style="zoom:33%;" /><p>大体满足要求，但仍存在一些问题：</p><ol><li>pages的信息没有解码，可以转成中文的</li><li>top referrers里面有来自 workers的<code>https://keyc-analytics.1659057796.workers.dev/</code>，不知道什么原理，希望不会在访问阶段产生性能损失</li><li>地图是乌克兰提供的，看看有没有更优美的实现方案</li><li>前端界面还是不够优美，有些块太大了，浏览器缩小的时候不能自动调整大小</li><li>keyc.top/__dash是怎么实现的？出乎意料，我以为是用workers提供的域名，需要解释为什么需要配置route？</li><li>需要解释下为什么要配置D1 database，和workers是如何协作的？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">  %% ========= Traffic path =========</span><br><span class="line">  U[Visitor Browser] --&gt;|HTTPS request to keyc.top| CF[Cloudflare Edge]</span><br><span class="line"></span><br><span class="line">  CF --&gt;|Route: keyc.top/* -&gt; Worker| W[Worker: Analytics Proxy]</span><br><span class="line"></span><br><span class="line">  subgraph Origin[&quot;Origin Hosting&quot;]</span><br><span class="line">    GH[GitHub Pages\n(owner.github.io / repo pages)]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  W --&gt;|fetch(request)\nproxy to origin| GH</span><br><span class="line">  GH --&gt;|HTML response| W</span><br><span class="line">  W --&gt;|Return response to visitor| CF</span><br><span class="line">  CF --&gt;|Serve page| U</span><br><span class="line"></span><br><span class="line">  %% ========= Async logging =========</span><br><span class="line">  subgraph Storage[&quot;Storage&quot;]</span><br><span class="line">    D1[(D1 Database\nSQLite-compatible)]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  W -.-&gt;|ctx.waitUntil()\nINSERT event row| D1</span><br><span class="line"></span><br><span class="line">  %% ========= Dashboard path =========</span><br><span class="line">  A[Admin (You)] --&gt;|GET /__dash?key=...| CF</span><br><span class="line">  CF --&gt;|Route to Worker| W</span><br><span class="line">  W --&gt;|Return dashboard HTML| A</span><br><span class="line"></span><br><span class="line">  A --&gt;|XHR fetch /__api/summary\n/__api/map\n/__api/timeseries| CF</span><br><span class="line">  CF --&gt;|Route to Worker| W</span><br><span class="line">  W --&gt;|SELECT aggregates\nGROUP BY ...| D1</span><br><span class="line">  D1 --&gt;|rows| W</span><br><span class="line">  W --&gt;|JSON results| A</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基于-Cloudflare-Workers-搭建-VPN"><a href="#基于-Cloudflare-Workers-搭建-VPN" class="headerlink" title="基于 Cloudflare Workers 搭建 VPN"></a>基于 Cloudflare Workers 搭建 VPN</h2><p><a href="https://www.youtube.com/watch?v=Y_SHcD3prt8">https://www.youtube.com/watch?v=Y_SHcD3prt8</a></p><p><a href="https://github.com/yonggekkk/Cloudflare-vless-trojan">https://github.com/yonggekkk/Cloudflare-vless-trojan</a></p><h3 id="edge-tunnel"><a href="#edge-tunnel" class="headerlink" title="edge tunnel"></a>edge tunnel</h3><p><a href="https://github.com/cmliu/edgetunnel?tab=readme-ov-file">https://github.com/cmliu/edgetunnel?tab=readme-ov-file</a></p><p>我最终选择部署项目edge tunnel，worker page给的原始域名是<strong>zyc456.pages.dev</strong>，</p><p><a href="https://edt2.net.keyc.top/admin">https://edt2.net.keyc.top/admin</a> 我使用了自定义的域名，这样之后即使更换worker，部署新的服务，我也可以只更改DNS解析的配置，就可以调整到新的服务。如果我给多个人提供服务，固定这个订阅链接可能比较方便。</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20260201011313128.png" alt="image-20260201011313128" style="zoom:33%;" /><p>效果：</p><ol><li>谷歌搜索，谷歌地图，youtube，流畅快速</li><li>谷歌学术，能进入搜索界面，但是不能搜索</li><li>X，登陆环节有故障</li><li>chatgpt无法访问，gemini偶尔能够登上</li></ol><p>总体来说，仅供玩乐，可以作为视频专用或者梯子挂了备用的。</p><p>折腾了很多方式，现在很多项目被封了，也试用了sing-box，很多人又在开发新的隧道协议、加密协议、混淆手段、新的代理客户端/服务端、新的订阅链接格式、新的配置文件格式，对于用户来说，最终最需要的也不过是个<strong>快速稳定</strong>罢了。</p><h2 id="相关开源项目"><a href="#相关开源项目" class="headerlink" title="相关开源项目"></a>相关开源项目</h2><p><a href="https://developers.cloudflare.com/">https://developers.cloudflare.com/</a></p><p>官方文档，这是最权威、更新最快的信息来源。</p><p><a href="https://github.com/lyc8503/UptimeFlare/blob/main/README_zh-CN.md">https://github.com/lyc8503/UptimeFlare/blob/main/README_zh-CN.md</a></p><p><a href="https://github.com/lyc8503/UptimeFlare">UptimeFlare</a>一个由 Cloudflare Workers 驱动的功能丰富、Serverless 且免费的 Uptime 监控及状态页面。以后如果部署的服务多了，可以用类似的想法，监控各个服务是否可用。</p><p><a href="https://github.com/Zakkaus/cloudflare-stats-worker">https://github.com/Zakkaus/cloudflare-stats-worker</a> </p><p><a href="https://stats.zakk.au/">stats.zakk.au</a> 每日/30天的访问统计，热门页面</p><p><a href="https://miantiao.me/posts/sink/">https://miantiao.me/posts/sink/</a> 基于 Cloudflare 带访问统计的短链系统 7kstar</p><p><a href="https://github.com/uxiaohan/HanAnalytics">https://github.com/uxiaohan/HanAnalytics</a></p><p><a href="https://analytics.vvhan.com/">analytics.vvhan.com</a> 网络分析跟踪器和仪表板，在 Cloudflare Pages 上即可快速部署的网站分析仪表板,无成本稳定运行 300star</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Cloudflare Workers是我们最容易访问到的serverless服务，可以进行很多有意思的尝试，从尝试免费服务开始，学习它相关的技术。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="CloudFlare" scheme="https://keyc.top/tags/CloudFlare/"/>
    
    <category term="VPN" scheme="https://keyc.top/tags/VPN/"/>
    
    <category term="网络" scheme="https://keyc.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Serverless" scheme="https://keyc.top/tags/Serverless/"/>
    
  </entry>
  
  <entry>
    <title>2025年度总结</title>
    <link href="https://keyc.top/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://keyc.top/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2025-12-21T10:01:55.000Z</published>
    <updated>2026-02-01T10:18:35.709Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>2025这一年过得很快，我想把它总结为祛魅的一年。在这一年之前，我心里有很多渴望，有很多可望而不可及的东西，但这些东西都在今年得到了实现。</p><span id="more"></span><h2 id="工作与未来"><a href="#工作与未来" class="headerlink" title="工作与未来"></a>工作与未来</h2><blockquote><p>腾讯、阿里、微软、字节、快手、小红书、百度，顶会论文云团队，顶级开源项目，顶会论文mentor，大厂SSP，院士博士名额，大厂领导+1 +2 +3 +4 +5，AI比赛冠军</p></blockquote><p>今年最主要的命题就是找工作。我一开始觉得这件事非常重要，我不知道究竟是哪一个“偶然”会把我领到哪一个道路上，而我今后的命运就要与此绑定。因此当时我觉得我的每一个选择都很模糊而危险。</p><p>最开始是在二月的时候找实习。</p><h3 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h3><p>在二月中旬制作了英文简历，并且在截止的那天晚上投了微软。我当时花了很多时间看各个岗位描述JD，最终锁定了软件开发工程师SDE和云解决方案架构师CSA。我把CSA投在了第一个，命运的巧合引导我到了这条路。</p><p>微软的面试很开放也比较全面，我为它准备了专门的自我介绍，从三个角度介绍自己的优点，用自己的项目经历和竞赛经历等佐证，并且在每个角度都强调自己和这个岗位的匹配程度，这个自我介绍也是我后面其他众多面试的基础。</p><p>我在面试前做了很多准备工作，在Azure的云平台学习可以考它证书的课程；在各个平台搜索面经；准备了很多行为问题的回答：“对岗位的理解？为什么投这个岗位？如何解决冲突？”；准备了一些拿来反问的问题；调研了微软的企业文化，希望在回答的时候能够覆盖到，后来发现微软“顾客至上”这一点阿里也很重视。</p><p><strong>我每次面试前，我都会把自己调整到“自己是这个岗位最适合的候选者”的状态。</strong>我确实觉得我挺适合这个岗位：</p><ol><li><p>我有比较扎实的技术背景，技术覆盖面比较广。</p></li><li><p>这个岗位不单纯是技术，可以发挥我与人沟通的能力，而我的英文也不错，我的两个云项目都在我的推广下取得了不错的成果。</p><blockquote><p>我表达为“善于换位思考”，其实是源于微软文化中的“客户思维”。</p></blockquote></li><li><p>我坚持有耐心。</p></li></ol><p>三次面试，4月21收到offer，当时有很多微软裁员退出中国的消息，外企不再是主流的选择。</p><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><p>真正的第一个面试是腾讯，当时听说提前批不记录面评，就想着可以拿他赶紧练下手，了解下面试流程，看看自己哪些地方存在缺陷。</p><p>第一个捞我的是腾讯S线，2月26日，面试的过程实在是惨不忍睹，很多基础的知识都还没学，当时还有很多同学在旁边旁听。我不觉得丢脸，感谢这场面试给我暴露的很多问题，这种成长的心态让我好幸福。</p><p>没想到的是，这个面试官并没有给我挂，而是把我推给了同部门的同事，3月6日完成了三面，3月12日就收到了offer，我也是同学中第一个收到暑期offer的。</p><p>后来拒了这个offer，换CSIG面了一些，不想在成都也不想做数据库，又换了个做网络数据面加速/LB的部门，这个部门锻炼了我很多网络相关的知识，4月23收到这个部门的offer，当时已经决定去阿里云实习了。后面还有收到一些wxg的面邀，我当时还和他们说我想应聘产品经理（这是和一个教授聊天之后的结果，他建议我做产品经理更适合创业）。</p><p>秋招的时候，纠结了许久，投了后端WXG的青云计划，虽然不一定能通过，但是<strong>敢于投递本身也是一种祛魅。</strong>又经历了CDG的KPI面，WXG视频号的高强度智力题和算法题，非常感谢腾讯在这一年给我的面试，感谢每一个面试官，让我进步许多。</p><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>阿里云是心中的白月光，多少厉害的人和团队发表顶会论文，领导着多少顶级开源项目，还有很多师兄在那里。我对它有着浓厚的好奇心。</p><h4 id="GSOC"><a href="#GSOC" class="headerlink" title="GSOC"></a>GSOC</h4><p>是在二月的一个深夜，我在牛客刷GSoC相关的消息，刷到了Jin发的帖子，宣传今年RocketMQ的谷歌编程之夏，还可以边实习边做（RocketMQ是阿里云云原生消息团队贡献给Apache的顶级开源项目），当时我就觉得自己很契合，心里很激动，自己主动把简历发给了他。</p><p>其实参与GSoC才是我最大的渴望，前一年才知道这个活动，知道的时候已经晚了，只能留到今年和实习一起做，这也是我最后的机会。这个活动有很多好处，可以帮助我入开源的门，可以帮助我丰富秋招的简历，可以收获3000美元的奖励。我一开始其实计划去微软实习，因为微软的工作时间不长，空余时间可以做开源，硬实力和软实力同步提升，所以去阿里云实习和GSoC相比我更想拿到GSoC（现在来看GSoC对于简历的帮助并不大，还是阿里云实习更有含金量）。</p><p>它的申请过程也不简单，我一开始学习的过程遇到很多阻挠，主要就是网上RocketMQ 4.0和5.x文档混杂，新版本文档不多。这时候就需要看很多资料，必须大量输入不断输入，坐车的时候就在微信上看很多rocketmq的文章。很幸福的是，有女朋友可以在床边，我抱着mac边看源代码边给她解释，她让我更专注逻辑更清晰。申请截止的那天我一直做到两点，不慌不忙地写了一个很详细的文档，因为网站问题我差点没有提交成功。当时我也没有底，但是心里很渴望，我必须要这样努力，所幸通过了mentor和社区的审核。</p><h4 id="导师、领导与公司文化"><a href="#导师、领导与公司文化" class="headerlink" title="导师、领导与公司文化"></a>导师、领导与公司文化</h4><p>阿里云的面试也通过了，更幸运的是，我GSoC和实习的mentor都是Ji，我一开始就期待着这样，虽然不认识他但在后两轮面试中都给面试官提过他。他是浙大本硕，更厉害的是，他每年都能代表阿里云发一篇软件工程/分布式领域的顶会，我很想知道他是如何做到的，想知道在一个团队又能做科研又能做开源是什么样的体验。</p><p>他为人非常热情，表达很有条理，做事极其负责。在实习之前和我开过一次电话会，为我清晰地列举了我开源可能要做的几个事情，各自的优先级和难度。实习之前他就告诉我ld给我争取了一个商业化特性，告诉我时间节点让我心里有底。他说SSP包在他身上，当时我心里还没有这个奢望，不知道前路在何方，担心拿了白菜价那不如去读博，但他的话给人以希望。他思维敏捷，能够快速反应接话；善于总结包装展示，让人能够听懂他介绍的技术。<strong>希望几年之后我能够称为他这样的mentor</strong>。</p><p>在阿里云很幸运地，能够和各级领导接触。+1我的leader每个月都会和我单独聊天，问我有没有困难，在我家里有事情的时候让我放心回家。+2的部门领导有见面会，为我们介绍消息团队的发展。+3是云原生的领导，和他是一次偶然的野球（实习生误入天局），当时还有+4在，我就一直给+4传球；后来还加入云原生的足球队，在阿里云联赛中进球。还有+3见面会和部门KO大会，了解+4的成长路径，<strong>这些机会中能够了解整个行业的趋势，公司现在的发力点在哪里，应届生就应该面向这些需求去发展自身的能力</strong>。在实习生比赛中也获得了和靖人握手的机会。搜寻这些领导的履历，能看到很多领导都是名校毕业的，诸如中科大上海交大，高学历的他们走向职场之后依然努力。</p><p>我觉得阿里是众多大厂中最重视开源的公司，尤其是阿里云云原生有很多开源项目，我分析了这种商业模式：<a href="xxx">从Pulsar/RocketMQ看开源商业化</a>，首先为社区贡献好东西让大家都使用它，通过开源成为行业内的事实标准，而公司内部这个小团队拥有这个项目的核心领导权，能够影响这个产品的走向，这个团队出去的人，可以利用自己的技术积累在其他公司建立对这个产品的依赖，这个产品的影响力就越来越大，大模型开源也是类似的套路。但是其他公司的团队总是会慢一步，因为只有当核心团队将新特性发布，其他公司才能跟进。开源和论文带来的影响力，一方面让客户更信任增加营收，另一方面可以吸引很多人才。我发现这种商业模式下面，他们都不需要销售去开拓市场寻找客户，<strong>技术人员和技术能力就是最好的销售</strong>，因此我mentor这样的人才就那么重要。阿里云占据了公有云很大一部分份额，当他们有最多的客户，就可以形成数据飞轮，针对市场最紧迫的需求做出最快的迭代，采用opencore模式将特性逐步从商业版本推广到开源版本，那么其他团队总是会落后。当然，守江山不易，还是有一些机会去挑战旧技术的统治地位。</p><p>在实习过程中，我和女朋友一起逛了蚂蚁园区、淘宝西溪园区，思考阿里的文化。它的<strong>企业使命</strong>是“让天下没有难做的生意”，从这个角度出发可以解释他很多个BU的发展逻辑，比如淘宝是为商贩提供一个交易平台；阿里云是为其他小型用到互联网的公司提供云服务，让他们做生意更省心；支付宝是为了交易安全简单；<strong>特别是闲鱼我觉得它让个人也很方便地做生意</strong>。这个角度可以来理解阿里很多都是ToB做得更好。“客户第一，员工第二，股东第三”的说法和微软挺像，也算有指导意义。</p><h4 id="实习生AI大赛"><a href="#实习生AI大赛" class="headerlink" title="实习生AI大赛"></a>实习生AI大赛</h4><p>谁不想沾点AI呢，我一开始有想如何能够在秋招的时候转到类似AI coding的赛道，这就要求我保持学习相关知识。而今年阿里云的实习生大赛的赛题就是做一个Agent，我想这个经历也可以为简历增添一分，因此找了成电的两个同学一起参赛，一个是同教研室的同学，一个是实习隔壁组的同学。从去年开始，<strong>我就希望我做的东西就要做到同品类中最好</strong>，这不意味着一定要拿冠军，但是我要拿高标准要求自己，达到我标准中的<strong>最好</strong>。</p><p>整个比赛的过程是非常难忘的经历，我在那些天的时间里面又进入了一种兴奋的状态。故事的开始是曲折的，我认为这是一个产品大于技术的比赛，AI能够去解决的问题是需要被仔细选择的，不是任何事情都需要AI去替代。一开始我们几个人有很多的争论，每个人从自己的技术经验出发想了一些创意，但又会被其他队友或者自己质疑，没有几个有前景的创意，直到初赛的前一天下午，我们才确定了FinOps这个场景，才开始调研和思考。我们不像其他团队在初赛前就已经做好雏型，演练好几遍；我们是在初赛的赛场上开始编程。</p><p>初赛的赛制是58个队伍分成8组，每组只能有一支出线。所幸，我没想到，我们成为了出线的那一个。那天回去的班车上想，感谢命运，给了我弥补这次没有尽力的机会。复赛和初赛之间有一周的时间，那个周末我们来到公司加班（待到十一点多，拍了阿里云的月亮，不得不打车回去了，睡一觉第二天九点就开始比赛了），讨论如何优化我们的产品，是把它覆盖得云产品更多，还是把当前这个链路更加深化。我们决定把当前这个链路做得更完善，打磨AI生成的报告，增加记忆机制、RAG、知识库、优化MCP、ReAct和workflow链路等。和队友讨论的过程是幸福的，这次比赛也让我意识到队友的重要性。</p><p>在决赛答辩中，我们是最后一个，看着前面的人展示的产品，我觉得从完成度和价值上来看，确实没有我们好。当同学偷看到颁奖词上我们队伍的名字，发消息告诉我我们是冠军时，我也没有那么惊讶，因为我有这种预感，<strong>它来源于灵魂的渴望，当渴望足够强烈就会变成现实</strong>。</p><h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><ol><li>了解开源，了解商业模式，了解阿里</li><li>增强开发能力，补足了我在存储方面的一些知识，接触大型项目代码，熟悉大厂工作流程</li><li>业内很认可阿里云消息团队</li><li>简历增加商业化业务特性开发、高可用架构、AI Agent经历</li><li>认识了很多厉害的同事和同学，感谢每个人亲切的指导</li></ol><h3 id="小红书"><a href="#小红书" class="headerlink" title="小红书"></a>小红书</h3><p>如果说字节是几年前的阿里云，那么小红书就是几年前的字节。它像当初的“今日头条”，现在占据了百度搜索/知乎知识分享/抖音短视频直播/电商的一些份额，取得了自己的一个生态位。它的期权价格也是在一年的时间里面翻倍到了20美金，各个公司中可能只有它的期权有比较大的上涨空间。</p><p>感觉它的很多方面都是在模仿字节，比如它的企业文化是“inspire lives”，关键词是“主动”，“自驱”，“创造”，“成事”。在面试过程中我能够感受到，他们希望招聘的人是那种很有自驱力的，很希望做出一些东西的，对自己也比较有自信的，这种内核外化出来每个人可能就是“卷”，但是它和拼多多的卷不一样，我觉得它还是以人为本由自身驱动的，而不是拼多多单纯的资本主义耗材。也有成电的同学放弃了阿里清闲的ssp，选择小红书希望能够成长更多。</p><p>小红书面的是中间件岗位，我觉得基架在小红书不是核心的部门，它之所以成功可能更重要的是产品、运营和商业技术。它的面试体验挺好的，面试的推进速度很快，很快约面、很快反馈、很快下offer，很早说可以谈薪，我什么时候想开都可以。面试官和我说小红书招人很克制，希望保持作为一个“小公司”，可能是不想有那些大公司病。我了解到他们的人效比也很高，其他公司10几个人的团队他们只有三四个人。</p><p>小红书取消了职级，名义上这样让组织更扁平，底层员工可以更好地推动一个事情，当一个人有足够能力的时候，就可以成为负责人。但是我觉得不取消职级也可以推动事情，取消了的话跳槽其他公司可能就不好衡量他的能力，除此之外涨薪机制我没了解。对于校招生来说的话，如果不能在这里待2年，可能学不到什么东西还没有什么成长，跳槽的话别人不好给你定职级。</p><h3 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h3><p>一面的问题完全记不清了，二面和三面是很让人印象很深刻的。</p><p>二面的面试官比较瘦削精神，短头发微白，我会问他一些开放性问题，比如他对行业、技术发展趋势的看法，他们也尝试过推进FaaS，但是没有获得理想中的成功。</p><p>三面的面试官也有一种北方人的豪爽，我问他“为什么不选择创业”，他回答说“<strong>我有爱的人，我要对他们负责</strong>”，我每次看到一些让人感动的场景时，就会想到他和这句话，可能以后也会成为这样一个为家庭负责的人。</p><p>我问他“如何衡量一个员工的优秀”，他回答说“<strong>首先人是不能被比较的</strong>”。</p><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><h3 id="读博"><a href="#读博" class="headerlink" title="读博"></a>读博</h3><p>虽然我最终走向了字节，但事实上这条路存在着诸多岔路，读博就是其中一个。</p><p>在上半年实习的面试过程中，到取得了阿里云实习offer后，一直都在考虑要不要转博，尤其是一个<strong>院士博士学生的名额</strong>。研一的时候看一些同学保研成为了院士的学生，非常羡慕他们，感觉他们就高枕无忧了，想着如果自己也能有这个机会就好了。直到我也有了这个机会，才对它祛魅。</p><p>今年年初的时候，我导师旅游的时候就顺道经过了大连，当时我父母就和他表达了读博的意愿，还有其他教授也劝我，他们都觉得这条路读了肯定不后悔。我也拿不准主意，因为我很尊重这些长辈的意见，因为通过虚心学习我确实可以少走一些弯路，但是我又看不清楚未来会怎样。</p><p>感谢大导师能够惦记着我，先给我打电话通知了这件事，让我有优先选择权。但也只有几天时间，我当时很迷茫， 不知道自己读博之后的几年会是怎样的生活，当时在教研室楼顶和爸爸妈妈打了很多电话，分析得与失，和舒心坐在楼下聊，做她的工作。当时成都的天气也不好，阴天多，阳光少，我当时一想到即将在这里日复一日再度过四年就觉得不是很高兴，走在相同的楼梯成为最老的人。当时就已经和阿里云的leader和mentor建立了联系，感受到他们的热情，因此也对实习比较期待。如果转博的话，就算依旧去实习心态也会很奇怪。</p><p>于是我<strong>跟着感觉走</strong>，让感性带领理性，3月26拒绝这个offer。</p><p>后来呢，<strong>第十八届中国电子信息年会</strong>在成都举办，4月19日。这也是圆了一个愿望，去年我也关注这个会议，但是只能在线上看直播，羡慕那些在北京能够线下参加的人，没想到今年我就能线下参加了。这个会议很大，来了各种院士，学术新星，企业代表，我和舒心在这里参观学习。这时候又有了另一个转博的机会，和中国星网联培的项目，思考了几天之后，还是拒绝了。</p><h3 id="职业选择"><a href="#职业选择" class="headerlink" title="职业选择"></a>职业选择</h3><p>我想要找一条线把我的经历串联起来成为一个完整的故事。梳理了我个人的技术栈，作为信息与通信工程学院的学生，我在本科的时候同时学习“网络工程”和“通信工程”专业的课程，跟随抗干扰国家重点实验室做科研训练，研究生阶段用容器做网络模拟、卫星通信等，我认为我的这些经历都可以归为<strong>研究“信息/数据传递的过程”</strong>。我了解物理层从调制解调到编码解码的通信过程，了解计算机网络端到端数据传输的过程，了解各个场景下的数据传递，而我实习去的“消息队列”正是作为“应用层的交换机”。虽然信息的形态不一样，所处的场景不一样，但是计算机电子世界里解决问题的方式无非就是“计算、存储和网络”，区别是计算的位置、存储的对象和网络的环境，有些方法论是可以相通的。</p><p>我选择时只能寻找局部最优解，如果横轴是时间，纵轴是能力，<strong>我会不断选择成长速度最快（斜率最大）的那个事情</strong>。很早我就观察到，转博的同学在今年上半年就相对比较清闲，我觉得他们在这个时间获得的成长是没有我找实习、学习计算机八股、不断面试总结、以及去公司实习获得的成长大的。我看到很多找到工作的师兄师姐，在今年11月到明年毕业这个时间段比较清闲，放松了很多，我要引以为戒，不能浪费了这个时间，要去寻找这个时间里让我成长最快的事情。</p><h4 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h4><ol><li>公司发展前景、文化氛围：<ol><li>像小红书、字节和阿里云都是在上升期，上升的速度不一样，工作强度也不一样</li><li>其实无论哪个公司，尽管文化风格不一样，但是如果有想法我感觉公司都会给资源支持，哪个公司的动作都很迅速，都是聚集最优秀的人才</li></ol></li><li>部门/行业发展前景<ol><li>稳定？传统？现金奶牛？核心部门？中间件开发？业务开发？网络研发？行业影响力？</li><li>是否能够借助AI发展的潮流，是否是公司重视的部门</li><li>部门是否缺人、人员是否冗余</li></ol></li><li>领导&amp;同事<ol><li>选工作就是选领导，最重要的是跟对一个领导</li><li>领导的风格，话多/话少，是否低调内敛，是否看起来聪明</li><li><strong>因为相信，所以看见</strong>，看领导是否信任自己</li></ol></li><li>个人规划<ol><li>工作强度越大的地方，工作内容越需要与未来发展方向一致，需要自己感兴趣，因为没有其他时间让你去学习其他领域的知识，或者发展副业</li><li>不在乎开始几年的薪资多几万少几万，需要保持学习，因为十年之后一年的工资可能就是前五年的总和</li><li>到一个快速发展的地方，做到行业最好，有自己的成果</li></ol></li></ol><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>和业务开发不一样，中间件开发是造轮子的，为业务开发基础软件。我认为消息队列是一个最经典的一个中间件，AWS在2004年推出了第一个面向公共的IaaS服务，就是SQS（Simple Queue Service‌），AWS作为一项正式的商业服务于‌2006年‌推出，首批核心产品包括‌S3（简单存储服务）、EC2（弹性计算云）和SQS，这些服务共同奠定了IaaS的基础。消息队列团队在大部分公司都是服务于内部，属于中台团队，只有云厂商能够让他toB盈利，它也是阿里云云原生的一个现金奶牛。</p><p>走在中间件的道路是一个不错的选择：</p><ol><li>人才不是特别饱和，做这个事情的人不多（在迷糊时走到这方向的人不多），行业内可以来回跳</li><li>技术是相通的，分布式系统都能做</li><li>向上也可以做业务，但是很多人觉得业务开发CRUD比较无聊，中间件接触前沿和新东西比较多</li><li>周围同学去做网络的也好找工作，但跳槽局限在细分领域（其实都这样）</li><li>通过开源走向商业化的案例有很多，SaaS，PaaS</li><li>即使是去一些公司的中台部门（非盈利），消息队列也是一个不错的选择，因为一些中台团队会存在职责划分不清，和业务抢活的问题，但是消息队列作为一个经典的产品职责划分清晰，应该没有这个问题。</li></ol><p>当然，消息队列作为一个比较成熟的产品，给年轻人留的机会有多少是未可知的，可能因为我水平还不够没有看到这些机会；我也不知道他们新推出的诸如LiteTopic这种AI特性会有多少客户使用；我不知道他们会不会为赋新词强说愁……但无论大小，<strong>它所代表的“异步解耦、削峰填谷”的需求在任何时代都是有一席之地的</strong>。</p><h2 id="吃喝玩乐"><a href="#吃喝玩乐" class="headerlink" title="吃喝玩乐"></a>吃喝玩乐</h2><blockquote><p>杭州、上海、绍兴，许嵩、王力宏演唱会、深圳、香港、澳门、武汉</p></blockquote><p>我今年把心思都放在了找工作上，没有其他的兴趣，虽然没想去哪儿玩，也去了挺多地方。</p><p>第一次自己租房，可以在这个房间里将自己的很多想象变成现实。我在山姆买了个懒人沙发，好看但不是很舒服。</p><h3 id="最满意的一笔消费"><a href="#最满意的一笔消费" class="headerlink" title="最满意的一笔消费"></a>最满意的一笔消费</h3><p>今年最满意的一笔消费莫过于买了Macbook Air M3 13英寸24G +512G，可能花了7200多。Macbook Air就是苹果最精华的艺术品，它的轻薄比实习时使用的Pro体验更好。它反应快、流畅，我可以任意开软件，都不会有丝毫的卡顿。自从有了它我的主机就吃灰了。</p><h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><blockquote><p>刻意练习，明朝那些事儿，价值投资：从格雷厄姆到巴菲特，聪明的投资者，Serverless核心技术和大规模实践</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="其他成果"><a href="#其他成果" class="headerlink" title="其他成果"></a>其他成果</h3><p>2025 一等学业奖学金</p><p>电子科技大学优秀毕业生</p><p>研究生第一年排名是25/345，研究生第二年的排名是24/288，两年的综合排名是9/288（可惜没去申请国奖）</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20251228031703287.png" alt="image-20251228031703287" style="zoom: 50%;" /><p>第一发明人完成专利《一种基于优先级的分布式存储数据调度系统》</p><p>学生一作论文《天地一体化网络虚拟仿真实验设计》北大一级核心期刊《实验室研究与探索》录用</p><p>获得阿里云&amp;通义实习生 AI 大赛冠军</p><h3 id="心有所愿未所成"><a href="#心有所愿未所成" class="headerlink" title="心有所愿未所成"></a>心有所愿未所成</h3><ol><li>没能在实习之前这几个月的空档期把毕设做完发表一篇学术论文</li><li>没去申请国奖，以为自己的成果还不够</li><li>本来想找到实习之后，再找找研究型实习（其实阿里云mt也发论文也算做研究了）</li></ol><p>这些其实结果不重要，重要的是我要明白我内心中的懈怠，是我对自己要求的不严格让我没能达到这个目标。</p><h3 id="新的一年的希望"><a href="#新的一年的希望" class="headerlink" title="新的一年的希望"></a>新的一年的希望</h3><ol><li>能够在上班后租的地方买一个电子钢琴，下班也敲键盘，练习和弦音阶和即兴伴奏，能够转调，拍视频伴奏。</li><li>买一个书架，把看过的书放在上面。</li><li>能够和爸妈弟弟出国玩一次。</li><li>在自己住的地方维护一个干净优雅的网络，包括软路由，NAS等。</li></ol><p>至于事业等方面的目标，就不写在这里了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2025这一年过得很快，我想把它总结为祛魅的一年。在这一年之前，我心里有很多渴望，有很多可望而不可及的东西，但这些东西都在今年得到了实现。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>从Pulsar/RocketMQ看开源商业化</title>
    <link href="https://keyc.top/%E4%BB%8EPulsar-RocketMQ%E7%9C%8B%E5%BC%80%E6%BA%90%E5%95%86%E4%B8%9A%E5%8C%96/"/>
    <id>https://keyc.top/%E4%BB%8EPulsar-RocketMQ%E7%9C%8B%E5%BC%80%E6%BA%90%E5%95%86%E4%B8%9A%E5%8C%96/</id>
    <published>2025-12-06T15:50:45.000Z</published>
    <updated>2025-12-14T15:21:57.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在实习和秋招的过程中，一直都接触消息队列MQ，这也算是我职业生涯的起点。</p><p>我一直都对开源社区很好奇，更对它们如何商业化盈利好奇。</p><p>小红书、快手都在把技术栈从RocketMQ转型到Pulsar，腾讯听说也在内部大规模使用Pulsar，因此我最近也比较关注开源社区相关分享。</p><p>我关注到Pulsar的成长历程中，有StreamNative这个公司，</p><span id="more"></span><h2 id="相关背景"><a href="#相关背景" class="headerlink" title="相关背景"></a>相关背景</h2><h3 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h3><p>每次国内Pulsar的开源活动中，都能看到谙流科技和它创始人“翟佳”的影子，活跃在布道活动中。他是Apache Pulsar 和 Apache BookKeeper PMC 成员。</p><p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20251207001657983.png" alt="image-20251207001657983"></p><p>他和当时的 Apache Pulsar 创始团队成员郭斯杰一起创建了 StreamNative 公司，并且一直在维护并更新项目，他们也是项目和周边生态的主要贡献者。</p><p><strong>郭斯杰</strong>：创始人兼CEO，也是 Apache Pulsar 和 Apache BookKeeper 的PMC，曾任职于Yahoo和Twitter。Yahoo开发Pulsar的初衷就是为了解决Kafka在多租户和跨地域复制上的不足 。</p><p>StreamNative的早期策略是强调Pulsar优于Kafka的技术特性（如计算存储分离），但在2024-2025年，面对Confluent的强势，他们进行了关键的战略升级——<strong>拥抱湖仓一体（Lakehouse）</strong>。</p><p>StreamNative推出了专有的商业化引擎<strong>Ursa</strong>，这是一个构建在Pulsar之上的高性能层。支持将流数据直接以<strong>Apache Iceberg</strong> 或 <strong>Delta Lake</strong> 的格式写入对象存储，并无缝集成到Databricks或Snowflake中。</p><p>在消息领域的商业化公司，之前我听说的更多的是面向 Kafka 的 <a href="">Confluent</a> 和 <a href="https://www.automq.com/">AutoMQ</a>。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>为什么开源项目的star数会有上限，达到一定规模后增长就比较缓慢了？每年没有新的开发者进入和关注吗？</li><li>从RabbitMQ、Kafka到RocketMQ和Pulsar，一个消息产品的巅峰期能持续多久，它们背后的商业公司会受到怎样的影响？要一直依托在这个产品上吗？要转型吗？背后的创始人要做些什么呢？创始人是否能够持续保持影响力？</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在实习和秋招的过程中，一直都接触消息队列MQ，这也算是我职业生涯的起点。&lt;/p&gt;
&lt;p&gt;我一直都对开源社区很好奇，更对它们如何商业化盈利好奇。&lt;/p&gt;
&lt;p&gt;小红书、快手都在把技术栈从RocketMQ转型到Pulsar，腾讯听说也在内部大规模使用Pulsar，因此我最近也比较关注开源社区相关分享。&lt;/p&gt;
&lt;p&gt;我关注到Pulsar的成长历程中，有StreamNative这个公司，&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="RocketMQ" scheme="https://keyc.top/tags/RocketMQ/"/>
    
    <category term="开源" scheme="https://keyc.top/tags/%E5%BC%80%E6%BA%90/"/>
    
    <category term="Pulsar" scheme="https://keyc.top/tags/Pulsar/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ的新消息模型Lite Topic解析</title>
    <link href="https://keyc.top/RocketMQ%E7%9A%84%E6%96%B0%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8BLite-Topic%E8%A7%A3%E6%9E%90/"/>
    <id>https://keyc.top/RocketMQ%E7%9A%84%E6%96%B0%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8BLite-Topic%E8%A7%A3%E6%9E%90/</id>
    <published>2025-10-17T21:15:41.000Z</published>
    <updated>2025-10-18T21:32:50.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Apache RocketMQ 改进提案 <a href="https://github.com/apache/rocketmq/wiki/RIP%E2%80%9083-Lite-Topic:-A-New-Message-Model">RIP-83</a> 中提出了 Lite-Topic 模型。该提案为应对大规模分布式系统，特别是人工智能（AI）与多智能体（Multi-Agent）系统中的复杂通信需求，设计了一种全新的动态轻量级消息传递范式。文章将详细阐述 Lite-Topic 的核心设计、技术实现原理，包括其在存储层和消息分发机制上的创新，结合文章《<a href="https://rocketmq-learning.com/learning/rocketmq_learning-gvr7dx_awbbpb_atyw8nps43rzueq1/?spm=5176.29160081.0.0.21b17ebdyPETMD">Apache RocketMQ for AI 战略升级，开启 AI MQ 新时代</a>》分析其在 AI Agent 场景下的标准应用模型。</p><p>建议阅读原始英文版 <a href="https://github.com/apache/rocketmq/wiki/RIP%E2%80%9083-Lite-Topic:-A-New-Message-Model">RIP-83</a> 文档。</p><span id="more"></span><h2 id="背景与挑战"><a href="#背景与挑战" class="headerlink" title="背景与挑战"></a>背景与挑战</h2><p>现代分布式架构，尤其是在 AI 和事件驱动领域，对通信中间件提出了新的要求。传统的通信模式面临以下挑战：</p><ul><li><strong>同步通信的局限性</strong>：基于 gRPC 或 HTTP 的同步请求-响应模式，在面对长耗时任务（如 AI 模型推理）时，会导致调用方长时间阻塞，造成资源占用和系统级联延迟。</li><li><strong>传统发布/订阅模型的不足</strong>：标准的发布/订阅（Pub/Sub）模型主要用于一对多的消息广播，难以高效实现需要将消息（如任务结果）精确投递至特定请求方实例的场景。采用广播后客户端过滤或为每个实例创建独立 Topic 的变通方案，均存在效率低下或管理开销巨大的问题。</li></ul><p>因此，业界需要一种能够兼具消息队列的异步解耦、可靠传输能力，以及点对点通信精确性的新型消息模型，以支持海量、动态、有状态的通信场景。</p><h2 id="Lite-Topic-模型设计"><a href="#Lite-Topic-模型设计" class="headerlink" title="Lite-Topic 模型设计"></a>Lite-Topic 模型设计</h2><p>为应对上述挑战，RIP-83 提案引入了 Lite-Topic 模型。Lite-Topic 本质上是一种动态的、生命周期短暂的、轻量化的消息主题。其核心设计目标是为每一次临时的、有状态的交互按需创建通信通道，并在交互结束后自动回收资源。</p><p>其核心特性包括：</p><ul><li><strong>动态创建与回收</strong>：Topic 无需预先配置。当首个消费者订阅时，系统自动创建；当最后一个消费者取消订阅后，Topic 在预设的 TTL (Time-To-Live) 超时后被系统自动清理。</li><li><strong>轻量化</strong>：设计上支持单个集群内百万级别的 Topic 实例，其元数据管理和资源占用均经过高度优化。</li><li><strong>父子管理结构</strong>：每个 Lite-Topic 必须归属于一个预先创建的父 Topic。父 Topic 作为命名空间和管理单元，负责路由、权限控制等。</li><li><strong>精确路由</strong>：该模型专为细粒度消息路由设计，允许生产者将消息精确发送至由消费者动态订阅的特定 Lite-Topic。</li></ul><h2 id="核心技术实现原理"><a href="#核心技术实现原理" class="headerlink" title="核心技术实现原理"></a>核心技术实现原理</h2><p>为支撑百万级 Lite-Topic 的高效运行，该提案在 RocketMQ 的核心存储与分发层进行了两项关键的技术创新。</p><p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/O1CN01iKud7m22qpf29CE40_!!6000000007172-2-tps-3000-1688.png" alt="img"></p><h3 id="存储层设计：基于-KV-引擎的元数据管理"><a href="#存储层设计：基于-KV-引擎的元数据管理" class="headerlink" title="存储层设计：基于 KV 引擎的元数据管理"></a>存储层设计：基于 KV 引擎的元数据管理</h3><p>传统的 RocketMQ 为每个消息队列（ConsumerQueue）维护一个独立的索引文件，在 Topic 数量巨大时会引发文件句柄耗尽和磁盘 I/O 性能瓶颈。</p><p>Lite-Topic 的存储模型对此进行了优化：</p><ol><li><strong>数据与索引分离</strong>：所有消息数据仍统一顺序写入高吞吐的 <code>CommitLog</code> 文件。</li><li><strong>索引存储引擎替换</strong>：将存储消息索引的 <code>ConsumerQueue</code> 从传统的文件结构替换为高性能的嵌入式 KV 存储引擎（RocksDB）。每个 Lite-Topic 的消费队列索引被抽象为 KV 对进行存储，有效解决了海量 Topic 带来的文件系统压力和元数据管理难题。</li></ol><h3 id="消息分发机制：事件驱动拉取模型"><a href="#消息分发机制：事件驱动拉取模型" class="headerlink" title="消息分发机制：事件驱动拉取模型"></a>消息分发机制：事件驱动拉取模型</h3><p>传统长轮询机制在单一消费者订阅大量 Topic 的场景下（High-Fanout），会产生巨大的轮询请求开销。</p><p>为解决此问题，提案设计了事件驱动的拉取模型：</p><ol><li><strong>订阅关系维护</strong>：Broker 端精确记录并维护每个消费者（以 ClientID 标识）与所订阅的 Lite-Topic 列表之间的关系。</li><li><strong>就绪集管理</strong>：当新消息写入并路由至某个 Lite-Topic 时，Broker 会查询订阅关系。若发现有消费者订阅了该 Topic，则将该消息（或其索引）主动添加至为该消费者维护的一个内存队列，即“就绪集”。</li><li><strong>统一轮询</strong>：消费者客户端不再需要轮询成千上万个 Topic，而是仅对其自身的“就绪集”发起单一的 Poll 请求。Broker 可将来自不同 Lite-Topic 的消息在一次响应中批量返回给消费者。</li></ol><p>该模型将消费者 <code>N</code> 次的轮询请求优化为 <code>1</code> 次，显著降低了网络交互频率和系统负载，保证了在海量订阅场景下的低延迟与高吞吐。</p><h3 id="接口设计-变更"><a href="#接口设计-变更" class="headerlink" title="接口设计/变更"></a>接口设计/变更</h3><p>新的生产者 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增强的消息构建器，支持 lite topic</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> provider.newMessageBuilder()</span><br><span class="line">                    .setTopic(parentTopic)        <span class="comment">// 预先创建的父 Topic</span></span><br><span class="line">                    .setLiteTopic(liteTopic)      <span class="comment">// 动态的 lite topic</span></span><br><span class="line">                    .setTag(tag)</span><br><span class="line">                    .setKeys(<span class="string">&quot;KEY&quot;</span>)</span><br><span class="line">                    .setBody(body)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>新的消费者 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 lite topic 订阅的新的 LitePushConsumer</span></span><br><span class="line"><span class="type">LitePushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> provider.newLitePushConsumerBuilder()</span><br><span class="line">    .bindTopic(parentTopic) <span class="comment">// 绑定到父 Topic</span></span><br><span class="line">    .setConsumerGroup(consumerGroup)     </span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态订阅 lite topics</span></span><br><span class="line">pushConsumer.subscribeLite(liteTopic);</span><br></pre></td></tr></table></figure><h2 id="在-AI-Agent-场景下的应用模型"><a href="#在-AI-Agent-场景下的应用模型" class="headerlink" title="在 AI Agent 场景下的应用模型"></a>在 AI Agent 场景下的应用模型</h2><p>Lite-Topic 模型为 AI Agent 间的异步协作提供了标准的解决方案，尤其适用于长耗时的请求-回复模式。</p><p>一个标准的交互流程如下：</p><ol><li><strong>请求发起与通道建立</strong>：Agent A 在向 Agent B 发送任务请求时，消息体中包含一个动态生成的、唯一的 Lite-Topic 作为回复地址（例如 <code>a2a-reply-topic/&#123;taskID&#125;</code>）。同时，Agent A 动态订阅此 Lite-Topic，触发其在 Broker 端的自动创建。</li><li><strong>异步任务处理</strong>：Agent B 接收并异步执行长耗时任务。Agent A 无需阻塞等待。</li><li><strong>异步结果投递</strong>：Agent B 完成任务后，将结果消息发送至请求中指定的回复 Lite-Topic 地址。</li><li><strong>接收与通道拆除</strong>：Agent A 通过已建立的订阅关系接收到结果。任务流程结束后，Agent A 取消订阅。该 Lite-Topic 在 TTL 超时后被系统自动回收。</li></ol><p>此模型通过按需创建和销毁通信通道，将同步调用彻底解耦为可靠的异步消息传递，从而避免了级联阻塞，构建了高弹性、高可靠的 Agent 协作架构。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Apache RocketMQ 的 RIP-83 Lite-Topic 提案，通过在存储层引入 KV 引擎进行元数据管理，以及在分发层设计创新的事件驱动拉取模型，有效解决了传统通信范式在 AI Agent、复杂工作流等新兴应用中的局限性，为大规模动态消息场景提供了技术上可行且高效的解决方案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Apache RocketMQ 改进提案 &lt;a href=&quot;https://github.com/apache/rocketmq/wiki/RIP%E2%80%9083-Lite-Topic:-A-New-Message-Model&quot;&gt;RIP-83&lt;/a&gt; 中提出了 Lite-Topic 模型。该提案为应对大规模分布式系统，特别是人工智能（AI）与多智能体（Multi-Agent）系统中的复杂通信需求，设计了一种全新的动态轻量级消息传递范式。文章将详细阐述 Lite-Topic 的核心设计、技术实现原理，包括其在存储层和消息分发机制上的创新，结合文章《&lt;a href=&quot;https://rocketmq-learning.com/learning/rocketmq_learning-gvr7dx_awbbpb_atyw8nps43rzueq1/?spm=5176.29160081.0.0.21b17ebdyPETMD&quot;&gt;Apache RocketMQ for AI 战略升级，开启 AI MQ 新时代&lt;/a&gt;》分析其在 AI Agent 场景下的标准应用模型。&lt;/p&gt;
&lt;p&gt;建议阅读原始英文版 &lt;a href=&quot;https://github.com/apache/rocketmq/wiki/RIP%E2%80%9083-Lite-Topic:-A-New-Message-Model&quot;&gt;RIP-83&lt;/a&gt; 文档。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="RocketMQ" scheme="https://keyc.top/tags/RocketMQ/"/>
    
    <category term="Agent" scheme="https://keyc.top/tags/Agent/"/>
    
  </entry>
  
  <entry>
    <title>对于FaaS还存在哪些挑战？</title>
    <link href="https://keyc.top/%E5%AF%B9%E4%BA%8EFaaS%E8%BF%98%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%8C%91%E6%88%98%EF%BC%9F/"/>
    <id>https://keyc.top/%E5%AF%B9%E4%BA%8EFaaS%E8%BF%98%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%8C%91%E6%88%98%EF%BC%9F/</id>
    <published>2025-10-15T15:18:13.000Z</published>
    <updated>2025-10-18T20:13:16.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在阅读了《Serverless核心技术和大规模实践》这本书之后，除了吸收字节FaaS团队在解决实际问题时的设计思路，更重要的是思考这个领域还存在着什么问题，还应该去做哪些事情。</p><span id="more"></span><h2 id="FaaS架构的主要缺陷与挑战"><a href="#FaaS架构的主要缺陷与挑战" class="headerlink" title="FaaS架构的主要缺陷与挑战"></a>FaaS架构的主要缺陷与挑战</h2><h3 id="冷启动带来的性能问题"><a href="#冷启动带来的性能问题" class="headerlink" title="冷启动带来的性能问题"></a>冷启动带来的性能问题</h3><p>如果一个函数长时间未被调用，平台会回收其资源。当新的请求到来时，平台需要重新分配资源、拉取代码、启动运行时环境，这个过程会导致首次请求的延迟显著增高。</p><ul><li><strong>问题表现</strong>：对于延迟敏感的应用（如实时API），这种毛刺可能是无法接受的。</li><li><strong>书中佐证</strong>：本书花了大量篇幅来讨论冷启动问题及其优化方案，说明了它的重要性和复杂性。书中还将冷启动的耗时分解为调度延迟、容器创建、镜像拉取、进程启动等多个环节，并介绍了镜像代码分离、预热实例池等复杂的优化手段来缓解这个问题。</li></ul><h3 id="无状态的严格限制"><a href="#无状态的严格限制" class="headerlink" title="无状态的严格限制"></a>无状态的严格限制</h3><p>FaaS函数被设计为无状态的，这意味着不能依赖函数实例的本地内存或磁盘来保存两次调用之间的状态。</p><ul><li><strong>问题表现</strong>：对于需要维持状态的应用（如在线聊天、游戏服务器、复杂的交易流程），开发者必须将所有状态外部化，即存储到数据库、分布式缓存（如Redis）等外部服务中。这增加了架构的复杂度和对外部服务的依赖。</li><li><strong>书中佐证</strong>：在第11章的展望中，本书将<strong>状态管理</strong>列为Serverless未来需要攻克的一个重要方向。书中提到，当前函数只能依赖外部存储来解决状态共享问题，并期待未来能有满足低延迟、高吞吐、细粒度控制等特性的新型状态管理系统出现。</li></ul><h3 id="执行时长与适用场景限制"><a href="#执行时长与适用场景限制" class="headerlink" title="执行时长与适用场景限制"></a>执行时长与适用场景限制</h3><p>大多数FaaS平台的函数执行时间都有上限，通常是几分钟到十几分钟。</p><ul><li><strong>问题表现</strong>：这使得FaaS不适合需要长时间运行的单一任务，例如：<ul><li>大型数据批处理。</li><li>机器学习模型训练。</li><li>需要维持长连接的应用（如WebSocket服务器）。</li></ul></li><li><strong>书中方案</strong>：书中第8章设计了一套“<strong>异步长时间执行任务支持</strong>”的架构。</li></ul><h3 id="性能开销与高流量下的成本问题"><a href="#性能开销与高流量下的成本问题" class="headerlink" title="性能开销与高流量下的成本问题"></a>性能开销与高流量下的成本问题</h3><p>FaaS平台为了实现流量调度、安全隔离和监控，在调用链路上引入了额外的组件，如API网关和内部代理。</p><ul><li><strong>问题表现</strong>：这些额外的组件会带来一定的性能损耗。此外，虽然FaaS对低流量或偶发流量的应用成本极低，但对于持续性的高流量应用，其按请求次数计费的模式累加起来，<strong>总成本可能会超过一台长期运行的虚拟机或容器</strong>。</li><li><strong>书中佐证</strong>：书中第10章坦诚地指出了这个问题：“<strong>用户经常发现当请求量逐渐增多时，FaaS的成本优势就不再明显，甚至在请求量超过一定阈值后FaaS反而比常态保持实例的PaaS或者虚拟机计费更高</strong>”。原因之一就是平台为了管控流量而引入的“代理和管控消耗”。</li></ul><h3 id="厂商绑定与标准缺失"><a href="#厂商绑定与标准缺失" class="headerlink" title="厂商绑定与标准缺失"></a>厂商绑定与标准缺失</h3><p>不同云厂商的FaaS平台在函数签名、API接口、触发器配置和依赖管理等方面都有自己的实现，缺乏统一标准。</p><ul><li><strong>问题表现</strong>：一旦深度使用了一家厂商的FaaS生态（如AWS Lambda），想要将应用迁移到另一家（如Google Cloud Functions）会非常困难，需要重写大量代码。</li><li><strong>书中佐证</strong>：本书在第11章展望中也强调了这个问题，指出“<strong>各Serverless产品的发展……带来了一些标准不统一的问题，用户面临着厂商绑定的问题</strong>”。</li></ul><h3 id="调试与监控的复杂性"><a href="#调试与监控的复杂性" class="headerlink" title="调试与监控的复杂性"></a>调试与监控的复杂性</h3><p>FaaS应用是高度分布式的，一个业务请求可能会流经多个函数和后端服务。</p><ul><li><strong>问题表现</strong>：当出现问题时，追踪一个完整的调用链、定位故障点，比在单体应用中调试要困难得多。在本地复现云端的完整环境也很有挑战性。</li><li><strong>书中佐证</strong>：书中没有专门章节称其为“缺陷”，第3章用了大量篇幅介绍平台如何构建“<strong>可观测性</strong>”体系，包括<strong>日志、监控和链路追踪</strong>。这从侧面反映出，如果没有平台层面强大的可观测性支持，开发者将很难管理和排查他们的分布式FaaS应用。</li></ul><p>总结来说，FaaS用“免运维”和“弹性伸缩”的优势，换取开发者在<strong>性能一致性、状态管理、执行时长和开发模式</strong>上的让步。选择是否使用FaaS，可能是一个基于应用场景、团队技术栈的综合决策过程。</p><h2 id="本书思维导图"><a href="#本书思维导图" class="headerlink" title="本书思维导图"></a>本书思维导图</h2><p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/MindMap.png" alt="MindMap"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在阅读了《Serverless核心技术和大规模实践》这本书之后，除了吸收字节FaaS团队在解决实际问题时的设计思路，更重要的是思考这个领域还存在着什么问题，还应该去做哪些事情。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="Serverless" scheme="https://keyc.top/tags/Serverless/"/>
    
    <category term="FaaS" scheme="https://keyc.top/tags/FaaS/"/>
    
    <category term="字节" scheme="https://keyc.top/tags/%E5%AD%97%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用FaaS？</title>
    <link href="https://keyc.top/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8FaaS%EF%BC%9F/"/>
    <id>https://keyc.top/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8FaaS%EF%BC%9F/</id>
    <published>2025-10-14T13:28:23.000Z</published>
    <updated>2025-10-18T22:25:20.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在阅读《Serverless核心技术和大规模实践》这本书时，会有种和阅读其他教科书一样的感觉——知其然而不知其所以然。</p><p>我觉得根本原因是我对它提到的一些<strong>问题</strong>理解不够深刻，自然也难以get到它的解决方案的精妙之处。因此我这篇文章从上层业务出发，研究一下使用FaaS的一般是什么应用？它们为什么使用FaaS？这些应用对于底层平台带来了什么需求和要求？</p><span id="more"></span><h2 id="如何使用多个FaaS函数，共同构建一个完整的真实应用？"><a href="#如何使用多个FaaS函数，共同构建一个完整的真实应用？" class="headerlink" title="如何使用多个FaaS函数，共同构建一个完整的真实应用？"></a>如何使用多个FaaS函数，共同构建一个完整的真实应用？</h2><p>多个FaaS函数协同工作的核心思想，是将一个复杂的业务流程拆解成一系列独立的、职责单一的函数，它们之间通过<strong>事件</strong>或<strong>API调用</strong>连接起来，构建出一个灵活的事件驱动应用，通常被称为“Serverless微服务架构”。</p><p>以下是两个具体的例子：</p><h3 id="示例一：电子商务订单处理系统"><a href="#示例一：电子商务订单处理系统" class="headerlink" title="示例一：电子商务订单处理系统"></a>示例一：电子商务订单处理系统</h3><p>一个完整的订单流程可以被拆分成多个函数，通过消息队列（MQ）进行解耦。</p><ul><li><strong><code>function-create-order</code> (HTTP触发)</strong>: 接收前端下单请求，校验数据后将订单以“待支付”状态写入数据库，并发出一个 <code>ORDER_CREATED</code> 事件到消息队列。</li><li><strong><code>function-process-payment</code> (MQ触发)</strong>: 监听到 <code>ORDER_CREATED</code> 事件，调用第三方支付接口扣款，成功后更新订单状态为“已支付”，并发出 <code>PAYMENT_SUCCESS</code> 事件。</li><li><strong><code>function-update-inventory</code> (MQ触发)</strong>: 监听到 <code>PAYMENT_SUCCESS</code> 事件，在库存数据库中扣减相应商品数量，并发出 <code>INVENTORY_UPDATED</code> 事件。</li><li><strong><code>function-notify-logistics</code> (MQ触发)</strong>: 监听到 <code>INVENTORY_UPDATED</code> 事件，调用物流系统API，通知仓库准备发货。</li><li><strong><code>function-send-confirmation</code> (MQ触发)</strong>: 监听到支付或发货相关的事件，调用邮件服务，向用户发送订单确认和发货通知邮件。</li></ul><blockquote><p><strong>优势</strong>: 系统的每个环节都高度解耦，健壮性强。例如，物流系统暂时故障，不会影响支付和库存环节，相关的事件会在消息队列中排队，等待系统恢复后重试。</p></blockquote><h3 id="示例二：视频处理管道"><a href="#示例二：视频处理管道" class="headerlink" title="示例二：视频处理管道"></a>示例二：视频处理管道</h3><p>当用户上传一个视频后，系统需要对其进行转码、截图、审核等一系列并行或串行操作。</p><ul><li><strong><code>function-start-processing</code> (对象存储触发)</strong>: 当有新视频上传到存储桶时，该函数被自动触发，记录元数据并发出 <code>NEW_VIDEO</code> 事件。</li><li><strong><code>function-transcode-video</code> (MQ触发)</strong>: 监听到 <code>NEW_VIDEO</code> 事件，将视频转换为多种分辨率的版本。</li><li><strong><code>function-generate-thumbnail</code> (MQ触发)</strong>: 与转码函数<strong>并行工作</strong>，同样监听 <code>NEW_VIDEO</code> 事件，从视频中截取一帧作为封面图。</li><li><strong><code>function-content-moderation</code> (MQ触发)</strong>: 在转码或截图完成后，调用AI服务对内容进行安全审核，并将结果写回数据库。</li></ul><blockquote><p><strong>优势</strong>: 强大的并行处理能力。转码、截图、审核等耗时操作可以同时进行，且每个环节都能独立扩缩容，极大地提高了处理效率。</p></blockquote><h2 id="如果不使用FaaS，这些应用会是什么样？与FaaS架构相比有什么区别和不足？"><a href="#如果不使用FaaS，这些应用会是什么样？与FaaS架构相比有什么区别和不足？" class="headerlink" title="如果不使用FaaS，这些应用会是什么样？与FaaS架构相比有什么区别和不足？"></a>如果不使用FaaS，这些应用会是什么样？与FaaS架构相比有什么区别和不足？</h2><p>如果不使用FaaS，这些应用通常会采用<strong>单体应用</strong>或<strong>基于服务器/容器的微服务</strong>架构来构建。它们与FaaS在资源使用、运维模式和扩展性上存在差异。</p><ul><li><strong>单体应用</strong>: 订单处理的所有逻辑（支付、库存、物流）都封装在一个庞大的应用程序中，部署在长期运行的服务器上。</li><li><strong>基于服务器的微服务</strong>: 每个功能（支付服务、库存服务）都是一个独立的、长期运行的服务，部署在各自的虚拟机或容器中。需要自己维护这些服务和它们之间的通信。</li></ul><p>主要区别与不足：</p><table><thead><tr><th><strong>对比维度</strong></th><th><strong>FaaS 架构</strong></th><th><strong>传统架构</strong></th></tr></thead><tbody><tr><td><strong>运行方式</strong></td><td><strong>事件触发，按需执行</strong> 没有请求时，不运行，不产生计算费用。</td><td><strong>长期运行 (24/7)</strong> 无论有无请求，服务进程都必须保持运行。</td></tr><tr><td><strong>成本模型</strong></td><td><strong>按实际使用计费</strong> 真正实现“用多少付多少”，非常适合负载波动大的场景，无闲置成本。</td><td><strong>按预配资源计费</strong> 需要为峰值流量预留资源，导致在流量低谷期资源大量闲置，成本效率低。</td></tr><tr><td><strong>弹性伸缩</strong></td><td><strong>自动、瞬时、事件驱动</strong> 平台根据事件数量自动、快速地从0扩容到数千个实例，无需人工干预。</td><td><strong>被动、基于资源负载</strong> 需要手动配置复杂的伸缩规则（如CPU&gt;80%），响应有延迟，无法完美匹配突发流量。</td></tr><tr><td><strong>运维管理</strong></td><td><strong>平台托管 (Serverless)</strong> 开发者无需关心服务器、操作系统和补丁，只需专注于业务代码。</td><td><strong>开发者/运维负责</strong> 需要投入大量精力管理服务器、部署、监控、系统更新和安全。</td></tr><tr><td><strong>容错性</strong></td><td><strong>天生解耦</strong> 通过消息队列连接的函数，一个函数失败不会影响其他函数，系统健壮性高。</td><td><strong>高度耦合或依赖同步调用</strong> 单体应用中一个模块的崩溃可能导致整个应用瘫痪；微服务间的同步调用可能产生级联失败。</td></tr></tbody></table><p>总之，传统架构给予用户更多的底层控制权，但代价是高昂的资源成本和沉重的运维负担。<strong>FaaS架构的核心优势在于将这些复杂性交由平台处理，让用户能够以更低的成本、更快的速度和更高的灵活性来构建和迭代应用。</strong></p><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p>2020年的这篇论文《<a href="https://arxiv.org/abs/2008.11110">A Review of Serverless Use Cases and their Characteristics</a>》收集和分析了89个无服务器用例，来理解其特征，从而指导平台优化。</p><ul><li><strong>平台与领域</strong>: AWS是主导平台（80%），Web服务是主要应用领域（33%）。</li><li><strong>应用与函数</strong>: 大多数应用（82%）只包含5个或更少的函数，且多为短期运行。</li><li><strong>驱动因素</strong>: 成本、运维简化和可伸缩性是采用无服务器的主要动机。</li><li><strong>工作负载</strong>: 81%的用例表现出突发性（bursty）的工作负载。</li><li><strong>工作流</strong>: 约31%的用例包含工作流，但大多结构简单。</li><li><strong>数据量</strong>: 大多数（44%）执行处理的数据量小于1MB。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在阅读《Serverless核心技术和大规模实践》这本书时，会有种和阅读其他教科书一样的感觉——知其然而不知其所以然。&lt;/p&gt;
&lt;p&gt;我觉得根本原因是我对它提到的一些&lt;strong&gt;问题&lt;/strong&gt;理解不够深刻，自然也难以get到它的解决方案的精妙之处。因此我这篇文章从上层业务出发，研究一下使用FaaS的一般是什么应用？它们为什么使用FaaS？这些应用对于底层平台带来了什么需求和要求？&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="Serverless" scheme="https://keyc.top/tags/Serverless/"/>
    
    <category term="FaaS" scheme="https://keyc.top/tags/FaaS/"/>
    
    <category term="字节" scheme="https://keyc.top/tags/%E5%AD%97%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>云服务器连接世界</title>
    <link href="https://keyc.top/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E4%B8%96%E7%95%8C/"/>
    <id>https://keyc.top/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E4%B8%96%E7%95%8C/</id>
    <published>2025-10-12T06:39:09.000Z</published>
    <updated>2026-02-10T12:41:24.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>从大一大二起我心里就有个种子：亲手打造一个属于自己的VPN服务。不仅是为了摆脱对付费“梯子”的依赖，也是希望能为身边的朋友提供一份便利。可惜当时学艺不精，又缺乏清晰的指引，扎进了无关紧要的技术中迷失了方向，迟迟无法窥见其全貌。</p><p>直到最近，当我重新审视这个问题时才恍然大悟。抛开所有复杂的表象，代理服务的核心，不就是一个位于中间节点、高效执行“数据包转发”任务的进程吗？</p><p>我拆解了一下我的需求，这个代理只需要有以下特点和能力：</p><span id="more"></span><ol><li>具备公网IP——能够被我的终端设备访问。</li><li>位于海外——它本身能够顺畅地访问国外网站。</li></ol><p>运行在这个云服务器上的代理进程需要完成以下任务：</p><ol><li>支持终端设备和代理之间加密通信，避免被墙。</li><li>将终端设备的请求，转发到目标地址之后，再转发回给终端。</li></ol><h2 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h2><p>我薅过各大云厂商的云服务，国外的亚马逊、微软、谷歌对于学生都很友好，提供了充分的额度，可以免费使用一年的云服务器，而且都有国外的公网IP，很适合做这件事情。Azure是少有的不需要国外信用卡认证。它只需要我用学生邮箱认证，或者也可以使用<strong>Github学生认证</strong>。</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20241210225300731.png" alt="image-20241210225300731" style="zoom: 33%;" /><p>国内的阿里云、腾讯云之类，虽然也有羊毛但是国内的云服务器不能拿来翻墙。</p><h3 id="github学生认证"><a href="#github学生认证" class="headerlink" title="github学生认证"></a>github学生认证</h3><p><a href="https://github.com/settings/education/benefits">https://github.com/settings/education/benefits</a></p><p>我的经验如下：</p><ol><li><p>尽量使用手机认证，因为需要用手机摄像头拍照</p></li><li><p>只能身处学校，连接校园的wifi，因为有一步是验证当前位置（使用学校的vpn没有成功）</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20260130162417489.png" alt="image-20260130162417489" style="zoom:50%;" /></li><li><p>认证的文书，我选择的是学校官网导出的<strong>在读证明</strong>，包括中英文的：姓名、生日、学号、入学考试日期、专业、学制时间、研究生院的红章。这个成功率100%。</p></li></ol><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20260130161626472.png" alt="image-20260130161626472" style="zoom:50%;" /><p>刚刚随手认证了一下，4min就通过了，虽然我可能一年就毕业了，通过后学生认证的有效期是2年。</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20260130161821531.png" alt="image-20260130161821531" style="zoom:50%;" /><p>如果定位有问题，或者拍摄的照片里的信息没有被系统捕获到，系统很快就会打回。</p><h2 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h2><h3 id="X-UI"><a href="#X-UI" class="headerlink" title="X-UI"></a>X-UI</h3><p><a href="https://github.com/vaxilu/x-ui">https://github.com/vaxilu/x-ui</a></p><p>X-ui是一个支持多协议、多用户的 xray 面板。基于 <code>Xray-core</code>，可以通过网页界面管理和创建多个代理节点。</p><p>支持的协议：vmess、vless、trojan、shadowsocks、dokodemo-door、socks、http</p><p>我使用docker部署后运行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ba80439244d5   enwaiax/x-ui:latest   &quot;x-ui&quot;    7 weeks ago   Up 7 weeks (unhealthy)   0.0.0.0:9910-9920-&gt;9910-9920/tcp, 0.0.0.0:9910-9920-&gt;9910-9920/udp, [::]:9910-9920-&gt;9910-9920/tcp, [::]:9910-9920-&gt;9910-9920/udp, 0.0.0.0:9901-&gt;54321/tcp, [::]:9901-&gt;54321/tcp   x-ui</span><br></pre></td></tr></table></figure><p>注意要在云服务器厂商的配置界面，打开需要的端口。</p><p>我们可以在浏览器访问<code>http://&lt;服务器ip&gt;:9901/xui</code>进入配置界面。</p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/4009874650.png" alt="img" style="zoom:50%;" /><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/3339444791.png" alt="img" style="zoom:50%;" /><p>配置起来很简单，先添加入站，不懂的配置就不选，然后就获得了这个代理节点的详细配置信息。</p><h3 id="3X-UI"><a href="#3X-UI" class="headerlink" title="3X-UI"></a>3X-UI</h3><p><a href="https://github.com/MHSanaei/3x-ui/blob/main/README.zh_CN.md">https://github.com/MHSanaei/3x-ui/blob/main/README.zh_CN.md</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh | <span class="built_in">sudo</span> bash</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">═══════════════════════════════════════════</span><br><span class="line">     Panel Installation Complete!         </span><br><span class="line">═══════════════════════════════════════════</span><br><span class="line">Username:    hh0KDFsYB9</span><br><span class="line">Password:    0qm7iZ1ZEh</span><br><span class="line">Port:        5581</span><br><span class="line">WebBasePath: CUAAvbbUxxvPxx9XTtWAR</span><br><span class="line">Access URL:  https://52.188.9.36:5581/CUAAvbbUxxvPxx9XTtWAR</span><br><span class="line">═══════════════════════════════════════════</span><br><span class="line">┌───────────────────────────────────────────────────────┐</span><br><span class="line">│  x-ui control menu usages (subcommands):              │</span><br><span class="line">│                                                       │</span><br><span class="line">│  x-ui              - Admin Management Script          │</span><br><span class="line">│  x-ui start        - Start                            │</span><br><span class="line">│  x-ui stop         - Stop                             │</span><br><span class="line">│  x-ui restart      - Restart                          │</span><br><span class="line">│  x-ui status       - Current Status                   │</span><br><span class="line">│  x-ui settings     - Current Settings                 │</span><br><span class="line">│  x-ui enable       - Enable Autostart on OS Startup   │</span><br><span class="line">│  x-ui disable      - Disable Autostart on OS Startup  │</span><br><span class="line">│  x-ui log          - Check logs                       │</span><br><span class="line">│  x-ui banlog       - Check Fail2ban ban logs          │</span><br><span class="line">│  x-ui update       - Update                           │</span><br><span class="line">│  x-ui legacy       - Legacy version                   │</span><br><span class="line">│  x-ui install      - Install                          │</span><br><span class="line">│  x-ui uninstall    - Uninstall                        │</span><br><span class="line">└───────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>其实还需要把80端口打开，它会自动去获取ssl证书，如何运行脚本之前没打开，之后可以再运行x-ui命令补足这个工作。</p><h2 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h2><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><p>我的mac使用的代理软件是ClashX Pro，它有一个配置文件<code>clash_template.yaml</code>，我按照在X-ui中设置的内容，输入的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># VMess</span><br><span class="line">- name: &quot;v2ray&quot;</span><br><span class="line">  type: vmess</span><br><span class="line">  server: 74.111.113.112 #这个要改成你自己服务器的IP</span><br><span class="line">  port: 9910 #配置的port</span><br><span class="line">  uuid: 4bbf8b9b-ecfc-47b5-e4fd-f9f17321db16 #从X-ui中复制过来</span><br><span class="line">  alterId: 0</span><br><span class="line">  cipher: auto</span><br><span class="line">  # udp: true</span><br><span class="line">  # tls: true</span><br><span class="line">  # skip-cert-verify: true</span><br><span class="line">  # tls-hostname: 填写伪装域名</span><br><span class="line">  network: ws #这个是我选择伪装流量使用的协议</span><br><span class="line">  ws-path: /</span><br><span class="line">  # ws-headers: #这一行后面不要写东西</span><br><span class="line">  #   Host: v2ray.com # 填写伪装域名</span><br></pre></td></tr></table></figure><p><a href="https://github.com/clash-verge-rev/clash-verge-rev">https://github.com/clash-verge-rev/clash-verge-rev</a></p><p>clash verge是Mac windows linux等平台可以使用的另一个客户端。UI更好更直观。</p><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p>使用shadowrocket，可以手动添加节点，关键的配置参数也就是包括：</p><ol><li>Vmess等协议</li><li>地址、端口、UUID</li><li>传输方式：http/grpc/websocket等</li></ol><h2 id="订阅转换"><a href="#订阅转换" class="headerlink" title="订阅转换"></a>订阅转换</h2><p><a href="https://github.com/tindy2013/subconverter">https://github.com/tindy2013/subconverter</a></p><p>本地转换工具</p><p>订阅转换是一个很麻烦的过程，因为xui生成的网页订阅链接，可以很方便地导入shadowrocket等ios/windows客户端，但是不能轻松地导入clash，clash需要的是<a href="https://gist.github.com/mcxiaoke/d41b9f6aefe15002b38b95c96c60ffc0">yaml配置文件</a>，我没有在本地的客户端看到订阅格式转换的功能。要么就是根据自己在网页的配置，去手动修改yaml配置文件，但是我几经修改，总是还是存在格式或者参数上的问题（比如mldsa65-verify/  spider-x/ short-id等参数最后发现有的没填）。</p><p><a href="https://github.com/siiway/urlclash-converter">https://github.com/siiway/urlclash-converter</a></p><p>好在找到了<a href="https://convert.siiway.top/%E8%BF%99%E4%B8%AAClash">https://convert.siiway.top/这个Clash</a> (Mihomo) ↔ 节点链接 转换工具，把xui生成的vmess格式链接，转换成yaml格式的配置。</p><p><strong>这么基础的功能，clash本身应该支持呀？！</strong></p><p>订阅转换其实一般是用来把多个订阅源合并，但我暂时不需要。</p><h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p>自己建的梯子的使用效果简直完美，访问谷歌搜索的速度比之前的付费梯子快了不知多少，youtube带宽至少可以到2MB/s毫不影响观看。ClashX Pro上显示的延迟是400ms。</p><p>更重要的是，<strong>这个纯净的ip只有我个人使用，可以访问Claude这种严格封锁中国IP的网站，使用最新的模型。</strong></p><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>我目前没有使用配置TLS，但是一个没有TLS保护的代理服务，它的数据流在握手和传输阶段有着独特的“指纹”可能被网络审查系统通过深度包检测（DPI）技术识别。</p><p>为代理服务配置TLS后，所有流量都会被封装在标准的HTTPS协议中。</p><ol><li><strong>流量伪装</strong>: 这是最核心的优势。开启TLS后，代理流量在外观上与浏览任何一个普通安全网站（例如 <code>https://google.com</code>）的流量变得完全无法区分。将自己伪装成海量日常网络活动的一部分，让审查系统无从下手，因为不可能为了拦截少数目标而切断所有正常的HTTPS访问。</li><li><strong>抵御主动探测</strong>: 当外部系统试图探测服务器端口以识别服务类型时，开启TLS的端口会返回一个标准的、无懈可击的Web服务器响应。探测方无法借此判断背后运行的究竟是普通网站还是代理服务，从而使其失效。</li><li><strong>连接的健壮性</strong>: 启用TLS需要绑定一个域名。这意味着我们可以通过域名而非固定IP来连接服务。未来即便服务器IP被封锁，只需将域名解析到新的IP，客户端即可无缝切换，大大提高了服务的灵活性和抗封锁能力。</li></ol><h2 id="基于Cloudflare-Workers建立VPN"><a href="#基于Cloudflare-Workers建立VPN" class="headerlink" title="基于Cloudflare Workers建立VPN"></a>基于Cloudflare Workers建立VPN</h2><p><a href="https://www.youtube.com/watch?v=HcD4xYKXuRY">https://www.youtube.com/watch?v=HcD4xYKXuRY</a></p><p><a href="https://www.youtube.com/watch?v=755G850wXGw">https://www.youtube.com/watch?v=755G850wXGw</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从大一大二起我心里就有个种子：亲手打造一个属于自己的VPN服务。不仅是为了摆脱对付费“梯子”的依赖，也是希望能为身边的朋友提供一份便利。可惜当时学艺不精，又缺乏清晰的指引，扎进了无关紧要的技术中迷失了方向，迟迟无法窥见其全貌。&lt;/p&gt;
&lt;p&gt;直到最近，当我重新审视这个问题时才恍然大悟。抛开所有复杂的表象，代理服务的核心，不就是一个位于中间节点、高效执行“数据包转发”任务的进程吗？&lt;/p&gt;
&lt;p&gt;我拆解了一下我的需求，这个代理只需要有以下特点和能力：&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="VPN" scheme="https://keyc.top/tags/VPN/"/>
    
    <category term="Proxy" scheme="https://keyc.top/tags/Proxy/"/>
    
    <category term="云服务器" scheme="https://keyc.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>2024年度总结</title>
    <link href="https://keyc.top/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://keyc.top/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2024-12-16T14:40:19.000Z</published>
    <updated>2025-01-07T08:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是我的2024年度总结，记录这一年的回忆与收获。</p><span id="more"></span><h1 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h1><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p>《计算机通信网络》助教</p><blockquote><p>python实验、wireshark实验、思科网院实验、虚仿实验。<br>虚仿实验重新整理指导书和实验报告模板，针对每个实验的核心知识点，对整个体系进行梳理。</p></blockquote><p>《图论及应用》集中复习的时候觉得这个课很有哲理。《学术英语》《研究生论文写作指导》《大数据交叉科学研究前沿》《机器学习研究中的优化方法》《可视数据分析》《先进计算机网络》《新一代移动通信系统》</p><h2 id="汇报与申报书"><a href="#汇报与申报书" class="headerlink" title="汇报与申报书"></a>汇报与申报书</h2><p>20240726 - sigcomm海报&amp;演示视频</p><p>20240817 - “科教融汇”虚仿实验项目探索与实践：面向计算机网络教学 PPT</p><blockquote><p>总结各个教学实验的实验内容、教学目标、天地异构网络实验总结和截图等</p></blockquote><p>20240907 - “天基算网融合”汇报 PPT</p><blockquote><p>充分调研对比其他<strong>卫星网络试验平台</strong>，进行<strong>边缘资源受限网络中的张量并行推理</strong>实验 ，重新绘制中文架构图</p></blockquote><p>20240927 - 清华交流演示</p><p>20241020 - “RIGOL杯”全国电子信息类专业课程实验教学案例设计竞赛</p><p>20241113 - ”产学研创新基金“本子</p><p>20241119 - 学校研究生学术论坛 海报</p><p>20241201 - 上交实验平台交流 PPT</p><blockquote><p>完整整理平台至今和教学相关的所有资料，整理最新获奖，调整PPT表述</p></blockquote><p>20241211 - “SDN组网平台”本子</p><blockquote><p>完整整理平台SDN相关架构，pcap、ebpf监控，DPDK，虚实结合等技术的实现方式，将平台包装成SDN组网验证平台</p></blockquote><p>20241227 - “天地一体化”教研论文</p><blockquote><p>整体结构、各层的主要功能、以及各层的主要交互</p></blockquote><h2 id="奖项"><a href="#奖项" class="headerlink" title="奖项"></a>奖项</h2><p>2024 十九届”挑战杯”全国大学生课外学术科技作品竞赛2024年度“揭榜挂帅”专项赛 国家一等奖（“灵阵”网络靶场试验平台）</p><p>2024 电子科技大学优秀研究生</p><p>2024 研究生一等学业奖学金</p><p>2024 第十八届IEEEXtreme极限编程大赛全球前6.4%（385/5998）</p><p>2024 信息与通信工程学院 研究生学术论坛 最佳海报展示奖</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ACM SIGCOMM Posters and Demos 2024 Klonet-sat: A Comprehensive Platform for Satellite Network Education</p><p>2024 “卫星互联网虚拟仿真实验”项目荣获第四届“RIGOL杯”全国高校电子信息类专业课程实验教学案例设计竞赛西部赛区二等奖 全国三等奖（教育部高等学校电子信息类专业教学指导委员会，国家级实验教学示范中心联席会电子学科组，中国电子教育学会）</p><p>2024年 天地一体化网络虚拟仿真实验 第六届中国计算机教育大会计算机类教学和实验案例 特等奖 （教育部高等学校计算机类专业教学指导委员会，全国高等学校计算机教学与产业实践资源建设专家委员会）</p><p>2024年3月 大规模云网融合的柔性适配关键技术及应用 中国电子学会 科技进步奖 二等奖 </p><h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><p>2月 沈阳 with bro&amp;yxm 2.16</p><p>5月 五一西双版纳&amp;昆明</p><p>7月 乐山 with ysn</p><p>8月 悉尼 with gjh </p><p>8月 杭州</p><p>8月 内蒙古 8.13~8.18</p><p>8月 旅顺 8.22</p><p>9月 重庆-李宗盛演唱会</p><p>10月 深圳-香港</p><p>11月 谭咏麟演唱会 with zfy</p><p>11月 西安-梁静茹演唱会</p><p>12月 大连三天</p><h1 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h1><p>文学类：《树上的男爵》《君幸食》</p><p>政治经济社科类：《美丽新世界》《多谈谈问题》</p><p>人物传记类：《三生万物》《史蒂夫·乔布斯传》</p><p>科技哲学类：《黑客与画家》《程序员的 README》</p><p>《三生万物》</p><p>《黑客与画家》</p><p>《君幸食》</p><p>《美丽新世界》</p><p>《多谈谈问题》</p><p>《程序员的 README 》</p><p>《克拉拉与太阳》</p><p>《史蒂夫·乔布斯传》</p><p>《树上的男爵》</p><h1 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h1><h2 id="网易云音乐网盘快速上传工具与闲鱼小店"><a href="#网易云音乐网盘快速上传工具与闲鱼小店" class="headerlink" title="网易云音乐网盘快速上传工具与闲鱼小店"></a>网易云音乐网盘快速上传工具与闲鱼小店</h2><p>在11月初的时候，萌生了做这样一个工具的想法。其实一开始只是自己需要把周杰伦的歌曲都上传到自己的网易云音乐，这样就可以在一个app听我所有喜欢的歌曲了，然后就在网上挑选对比免费的音乐资源，终找到了一个音质和排版都比较满意的资源，在客户端很快就全都传到了网盘里。</p><p>这时候我想，能不能利用网易云音乐相关接口，制作一个自动化的工具，让所有和我一样有需求的人，直达结果。现在来看，做这个事情是多方面因素共同作用的结果：</p><ol><li>我认同我最终做的事情的出路要从自己身边寻找：平时在什么事情上花的时间多，就从什么地方开始自己的副业。我平时听音乐多，在闲鱼买东西多，平时写代码，所以这件事情恰好符合几个我熟悉的领域的交集。</li><li>深圳旅行对我的触动，一切始于足下。那个老板也是在年轻的时候做了很多的尝试，比如每天在香港海关给人拍照，当初做的小事都是未来的铺垫；他在深夜和清晨坚持学习，研究电商平台的规则、拓展新的业务。</li><li>11月在读的书是《黑客与画家》，这本书中有一个概念改变了我的认知：财富是可以被创造的，而我之前以为大量的财富只有依靠剥削。我做一个这样的工具，正好是节约了别人的时间和精力，做出了别人需要的东西，让这个社会的财富总量增加。</li><li>在技术方面有两个因素：“编程工具的快速发展”与“第一性原理”。<ul><li>我喜欢尝试各种先进的AI工具，我感觉它可以将我的能力放大到我还无法想象的程度，我也觉得新时代每个人可能都是一个强大的全栈工程师，因此我想通过一个项目试验自己的学习能力、工程能力和效率。</li><li>马斯克多次在采访中提到“第一性原理”，在计算机领域，我特别认同他的这个观点，目前我所涉及的领域都是由“人”设计的，也就是说它遇到的绝大部分问题都是可解释的。如果遇到了一个问题，可以通过钻得更深、更细粒度地分解来找到解决办法。我想要在这件事情上运用这个方法论。</li></ul></li></ol><h3 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h3><h4 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h4><ol><li>寻找已有开源接口资源</li><li>利用cursor部署使用JS项目，学习框架执行逻辑</li><li>提取几个关键接口，形成可以完成用户登陆、上传音乐功能的最小原型</li><li>用户session设计：创建、更新状态、结束等逻辑，确保每个用户的链接只能用一次</li><li>前端界面设计：二维码获取、绘制与更新；上传进度展示；后端接口触发机制</li><li>结合歌曲数据库构建“云盘歌曲匹配修正”功能模块，修正错误匹配的歌曲</li></ol><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><ol><li>寻找具有公网ip的服务器——amazon</li><li>frp将公网服务器与内网机器建立连接</li><li>端口管理、防火墙管理、nginx代理</li><li><code>node app.js PORT=4000</code></li></ol><h4 id="音乐资源"><a href="#音乐资源" class="headerlink" title="音乐资源"></a>音乐资源</h4><ol><li>搜集对比多方音源，找到自己最满意的、适合日常听的音质</li><li>上传到网易云查看上传效果：有的歌名错误、没有歌词封面、有的匹配到错误的歌曲、歌曲乱序不成体系</li><li>使用爬虫，获取歌手全部专辑及其歌曲在网易云的信息</li><li>使用python一次性脚本对歌曲修正：将繁体字改为简体字，内嵌信息修正</li><li>使用python构建歌曲文件与网易云曲库映射的数据库</li><li>解决不同的两首歌上传时被当作相同的歌，导致不能上传的问题</li></ol><h3 id="中期"><a href="#中期" class="headerlink" title="中期"></a>中期</h3><h4 id="迭代与运维"><a href="#迭代与运维" class="headerlink" title="迭代与运维"></a>迭代与运维</h4><ol><li><p>解决用户并发问题：</p><ol><li>使用js的多进程，每来一个用户都新开一个子进程</li><li>手动负载均衡，使用多个端口，人为决定使用给用户用哪个端口传</li></ol></li><li><p>Proxyman/TCPView/Wireshark 抓包仔细分析上传过程</p><blockquote><p>我发现网易云客户端上传得很快（几秒），然而我自己使用接口的时候很慢（30秒），我认为客户端使用了某种技术，抓包发现在上传歌曲的时候，最主要的接口并不需要真的上传文件，而只是通过md5判断云端数据库是否有其他用户上传过同样的文件，然而我在初版的实现中，每首歌都要计算md5，这也解释了为什么我的多进程没有实质效果，因为即使是多进程，每个进程还是只能使用单核的性能来计算md5，这个工作会占满一个核心的资源。我想到，我只需要计算一次md5，保存到数据库，以后每次直接取用就好。</p></blockquote></li><li><p>多进程的session map的传递太过麻烦和混乱，而且后来也有很多音乐数据要管理，因此使用redis数据库</p></li><li><p>用户链接<code>==商品==钱</code>生成方式：</p><ul><li>一开始是专门制作了一个用于创建有效链接的前端页面，来一个顾客就去点击、生成、复制，可以应对每天个位数的顾客。</li><li>后来制作了一个生成链接的http接口，使用iphone的快捷操作就可以调用这个接口并解析获得的json，这样就可以一键获得有效链接。这种方式可以应对每天20+的顾客。</li><li>最后使用的redis和闲管家之后，就使用一个脚本，每次生成200个链接自动存到redis和一个txt，我再添加到闲管家让它自动发货，这样我的维护操作就简化到几天一次。</li></ul></li><li><p>服务器宕机：有一次因为使用了负载较高的容器，把云服务器搞崩了，因此紧急在azure申请了新的免费服务器，重新部署frp</p></li></ol><h4 id="销售与运营"><a href="#销售与运营" class="headerlink" title="销售与运营"></a>销售与运营</h4><p>这是很有意思的部分，也是很没有意思的部分，这部分给了我很多感悟和思考。</p><ol><li><p>锻炼了<strong>海报的制作</strong>（花了一下午，尽量有现代感，突出重点），把商品上架到我的闲鱼</p></li><li><p>一开始没有人来找我买东西，找了两三个亲朋刷了下单</p></li><li><p>觉得自己的东西确实是比同行其他人的更好（怀才不遇），无奈于平台不给我流量，因此一直在反思，尝试很多方法，比如<strong>降价</strong>，比如多次<strong>铺货</strong></p></li><li><p>我对初期阶段的每个顾客都<strong>心存感激</strong>，他们能够注意到我、我感觉是上天的恩赐，</p><blockquote><p>我最期待的就是他们的好评（这样以后就有更多人来买了），但这导致我每晚回一个顾客我都很遗憾，我把闲鱼设置了始终提醒，导致我每次手机一震，即使在睡觉也会瞬间清醒。<strong>这是我少有的，知道做一件自己喜欢做、自己想做的事情是什么感觉，那是始终精力充沛、思维不会丝毫转移的感觉。</strong></p></blockquote></li><li><p>我会经常性地改变商品的定价，在我销量低的时候，我会降价到0.97～1.98吸引销量；在我成为龙头之后，我就有一定的定价权，而我相信别人只要进到我店里就会选择我的东西，<strong>因此我可以达到这个领域最高的客单价1.58～3.98！</strong>每天都可以做实验，试验人们对价格的敏感度。</p></li><li><p>手动快速回复。在我还没有选择店铺管理工具之前，我只能一个个客户手动回复，为此，我研究了iphone的输入法短语的设置方式，设置快捷指令对接到平台接口。如果算12个h有60个顾客，平均12min就会有一个顾客，这种方式把我的时间切得很散。</p></li><li><p>自动化发货与回复。我选择了一个自动回复和自动发货的工具——闲管家，它可以把运营的流程大大简化。我可以连续3h不查看手机，隔一段时间回来看看零星的几个客户的问题。有了自动回复，我根据他们的问题不断增加匹配字段，问题覆盖率越来越高。<br>其实我的服务器不会出问题，最常出现的问题就是他们少复制了链接字段导致打不开网页。</p></li><li><p>监管与审查。我的账号</p></li></ol><h3 id="后期"><a href="#后期" class="headerlink" title="后期"></a>后期</h3><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/47ADF50D-B9C6-4638-8198-EDE180E04A17_1_101_o.jpeg" style="zoom:10%;" /><p>我最幸福的，就是我卖出去了1350单，没有一个差评，每个人都认可我的工作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是我的2024年度总结，记录这一年的回忆与收获。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="总结" scheme="https://keyc.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>《三生万物》——宁高宁</title>
    <link href="https://keyc.top/%E3%80%8A%E4%B8%89%E7%94%9F%E4%B8%87%E7%89%A9%E3%80%8B%E2%80%94%E2%80%94%E5%AE%81%E9%AB%98%E5%AE%81/"/>
    <id>https://keyc.top/%E3%80%8A%E4%B8%89%E7%94%9F%E4%B8%87%E7%89%A9%E3%80%8B%E2%80%94%E2%80%94%E5%AE%81%E9%AB%98%E5%AE%81/</id>
    <published>2024-12-15T12:44:39.000Z</published>
    <updated>2026-01-31T10:27:36.404Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这本书的作者是宁高宁，他是担任过三个超大型国企（世界500强企业）的领导人，华润、中粮和中化集团。</p><p>他的弟弟是宁光，中国工程院院士、上海瑞金医院院长；他的哥哥宁守诚也从事医学研究，美国斯坦福大学医学院终身教授。他的家庭也是医学世家。</p><span id="more"></span><p>宁高宁在2022年从中石化退休之后，写下了《三生万物》这本书，每一章都是讲三个东西。</p><h3 id="部分内容"><a href="#部分内容" class="headerlink" title="部分内容"></a>部分内容</h3><p>《三兄弟》，讲的是他们三兄弟的求学、成长与互相帮助；</p><p>《三老师》这一章讲的是对他成长非常有益了三位老师，分别是中学的生物老师，教了他达尔文主义，成为他学习其他经济学社会学的基础，还有山东大学经济学的政治经济学老师，匹兹堡大学的MBA的会计学老师，财务会计这门课让他受益匪浅；</p><p>《三城市》中讲的是美国匹兹堡、香港和北京，他在年轻时被国外的现代化所震撼，在香港的18年得益于它的开放自由，公司和自己都得到了巨大的成长，在北京，他有了放眼全国的视野和胸怀。</p><p>《三标识》他为三个企业设计了新的企业标识，从华润的“与您携手，改变生活”，到中粮的“自然之源，重塑你我”，再到中化集团的“科学之上”。</p><p>《三字文》讲述了他对写作的看法，语言的表达和传递能力是作为一个企业领导人所必备的；<strong>领导力是充分感受别人心思和需求的能力，感受到别人的需求，认识到自己的位置，同时不断地沟通、表达、理解、融合，与组织的目标融为一体</strong>。他在每家公司，都写了很多文章，因为大家都希望去了解他的思想、逻辑和背后的成因。</p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><ul><li>他在很多地方章节都讲了他的企业管理思路，讲到了他在各个企业的使命感和愿景。未来企业竞争生存只有一条路：技术创新产业升级；几乎所有行业的战略：技术、创新、研发、科学至上。</li><li>他做事的思路都很有大局观，并不喜欢投资金融等赚快钱的行为，房地产也是采取建立商业中心这种“长期主义”。</li><li><strong>读书是为了培养逻辑思维，还需要通过简洁、准确的语言把思考表达出来。读是学习思考，写是更深入的思考。</strong></li><li>不读书也不知道，其实大部分事情别人都说过了。</li></ul><h3 id="附录：涉足行业"><a href="#附录：涉足行业" class="headerlink" title="附录：涉足行业"></a>附录：涉足行业</h3><p>公路电力码头等基础设施行业，机械纺织食品化工等工业制造业，包括各种吃的东西的消费品行业，金融业等服务行业，半导体生物科学等科技行业，房地产行业等。</p><p>在华润时，建立了华润啤酒（雪花啤酒）、华润万家、万象城等。华润早期是贸易公司，高峰期占到全国外贸进出口的1/4还多，</p><p>在中粮时，助力它成为世界级大粮商，建立了大悦城，投资蒙牛，长城葡萄酒。酒鬼酒。</p><p>中化集团的前身是中国进出口贸易公司，他在这里也留下了览秀城。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这本书的作者是宁高宁，他是担任过三个超大型国企（世界500强企业）的领导人，华润、中粮和中化集团。&lt;/p&gt;
&lt;p&gt;他的弟弟是宁光，中国工程院院士、上海瑞金医院院长；他的哥哥宁守诚也从事医学研究，美国斯坦福大学医学院终身教授。他的家庭也是医学世家。&lt;/p&gt;</summary>
    
    
    
    <category term="所见所闻" scheme="https://keyc.top/categories/%E6%89%80%E8%A7%81%E6%89%80%E9%97%BB/"/>
    
    
    <category term="总结" scheme="https://keyc.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="书评" scheme="https://keyc.top/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>网易云盘批量上传工具</title>
    <link href="https://keyc.top/%E7%BD%91%E6%98%93%E4%BA%91%E7%9B%98%E6%89%B9%E9%87%8F%E4%B8%8A%E4%BC%A0%E5%B7%A5%E5%85%B7/"/>
    <id>https://keyc.top/%E7%BD%91%E6%98%93%E4%BA%91%E7%9B%98%E6%89%B9%E9%87%8F%E4%B8%8A%E4%BC%A0%E5%B7%A5%E5%85%B7/</id>
    <published>2024-11-06T16:42:50.000Z</published>
    <updated>2024-11-06T17:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我开发了一个支持多用户批量上传到网易云盘的扩展功能模块，主要包括：批量音乐文件上传、音质选择（SQ/Hi-res）、自动与系统元数据信息匹配、会话管理系统。通过对多用户的<strong>session进行管理</strong>，实现并行上传不同曲库；通过对<strong>网易云曲库元数据的读取</strong>，创建了与本地音频的映射数据库，相比其他商家实现了0误差的歌曲匹配；在公网服务器与内网机器之间做<strong>内网穿透和nginx反向代理</strong>，同时依托<strong>前后端分离</strong>的设计思路，用户可以在公网访问上传服务。</p><span id="more"></span><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>NeteaseCloudMusicApi 是一个非常流行的开源项目，提供了网易云音乐的 Node.js API 实现。</p><p>原项目的主要特点：</p><ol><li>提供完整的网易云音乐API接口</li><li>基于Node.js实现</li><li>通过CSRF和请求伪造实现接口调用</li><li>支持多种使用方式（Node.js调用、TypeScript支持等）</li></ol><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><ul><li>generate.html: 生成上传链接</li><li>login.html: 扫码登录页面</li><li>upload.html: 文件上传界面</li><li>session.js: 会话管理模块</li><li>newupload.js: 上传核心逻辑</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>生成带session的登录链接</li><li>扫码登录并关联session</li><li>自动开始上传任务</li><li>实时监控上传进度</li></ol><h2 id="会话管理设计"><a href="#会话管理设计" class="headerlink" title="会话管理设计"></a>会话管理设计</h2><h3 id="Session存储结构"><a href="#Session存储结构" class="headerlink" title="Session存储结构"></a>Session存储结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储session信息</span></span><br><span class="line"><span class="keyword">const</span> sessions = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改处理函数格式以匹配项目要求</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">async</span> (query, request) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; sessionId, operation, cookie &#125; = query;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;save&#x27;</span>:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sessionId) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">status</span>: <span class="number">400</span>,</span><br><span class="line">                        <span class="attr">body</span>: &#123; <span class="attr">code</span>: <span class="number">400</span>, <span class="attr">message</span>: <span class="string">&#x27;sessionId不能为空&#x27;</span> &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 保存session信息，包括cookie和quality</span></span><br><span class="line">                sessions.<span class="title function_">set</span>(sessionId, &#123;</span><br><span class="line">                    <span class="attr">createdAt</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">                    <span class="attr">isUsed</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure><h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><ol><li><strong>会话有效期控制</strong></li></ol><ul><li>120分钟自动过期</li><li>一次性使用机制</li><li>登录状态验证</li></ul><ol start="2"><li><strong>Cookie安全</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果是上传阶段（已有cookie），则需要验证cookie</span></span><br><span class="line"><span class="keyword">if</span> (session.<span class="property">isUsed</span> &amp;&amp; session.<span class="property">cookie</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">body</span>: &#123; </span><br><span class="line">            <span class="attr">code</span>: <span class="number">200</span>, </span><br><span class="line">            <span class="attr">valid</span>: <span class="literal">true</span>, </span><br><span class="line">            <span class="attr">cookie</span>: session.<span class="property">cookie</span>,</span><br><span class="line">            <span class="attr">quality</span>: session.<span class="property">quality</span>,</span><br><span class="line">            <span class="attr">uid</span>: session.<span class="property">uid</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;Session有效&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录阶段，只验证session存在且未过期</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">200</span>,</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>状态转换控制</strong></li></ol><ul><li>idle -&gt; uploading -&gt; completed</li><li>异常自动回滚</li><li>延迟清理机制</li></ul><h2 id="文件上传实现"><a href="#文件上传实现" class="headerlink" title="文件上传实现"></a>文件上传实现</h2><h3 id="文件扫描"><a href="#文件扫描" class="headerlink" title="文件扫描"></a>文件扫描</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描目录获取音乐文件</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">scanDirectory</span>(<span class="params">dir</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> files = [];</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">await</span> fs.<span class="title function_">readdir</span>(dir);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">    <span class="keyword">const</span> fullPath = path.<span class="title function_">join</span>(dir, item);</span><br><span class="line">    <span class="keyword">const</span> stat = <span class="keyword">await</span> fs.<span class="title function_">stat</span>(fullPath);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (stat.<span class="title function_">isFile</span>() &amp;&amp; <span class="regexp">/\.(mp3|flac|wav|m4a)$/i</span>.<span class="title function_">test</span>(item)) &#123;</span><br><span class="line">      files.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>: fullPath,</span><br><span class="line">        <span class="attr">name</span>: item</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>支持多种音频格式</li><li>异步目录扫描</li><li>文件名规范化</li></ul><h3 id="上传任务管理"><a href="#上传任务管理" class="headerlink" title="上传任务管理"></a>上传任务管理</h3><ol><li><strong>状态对象设计</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建上传状态对象的工厂函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUploadStatus</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&#x27;idle&#x27;</span>,</span><br><span class="line">    <span class="attr">total</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">current</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">currentFile</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">files</span>: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>并发控制</strong></li></ol><ul><li>单任务队列</li><li>重试机制</li><li>进度追踪</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ol><li><strong>重试策略</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> retryCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> uploadSuccess = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (retryCount &lt; <span class="number">3</span> &amp;&amp; !uploadSuccess) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retryCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`正在进行第 <span class="subst">$&#123;retryCount&#125;</span> 次重试上传: <span class="subst">$&#123;file.name&#125;</span>`</span>);</span><br><span class="line">      <span class="comment">// 重试前等待一段时间</span></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>错误恢复</strong></li></ol><ul><li>最大重试次数限制</li><li>延迟重试</li><li>错误日志记录</li></ul><h2 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h2><h3 id="链接生成页面（管理平面）"><a href="#链接生成页面（管理平面）" class="headerlink" title="链接生成页面（管理平面）"></a>链接生成页面（管理平面）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateUUID</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/[xy]/g</span>, <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> r = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">16</span> | <span class="number">0</span>,</span><br><span class="line">            v = c == <span class="string">&#x27;x&#x27;</span> ? r : (r &amp; <span class="number">0x3</span> | <span class="number">0x8</span>);</span><br><span class="line">        <span class="keyword">return</span> v.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>UUID生成</li><li>音质选择</li><li>链接复制功能</li></ul><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h3><ol><li><strong>二维码登录流程</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getQRKey</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`/login/qr/key?timestamp=<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">unikey</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getQRCode</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`/login/qr/create?key=<span class="subst">$&#123;key&#125;</span>&amp;qrimg=true&amp;timestamp=<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">qrimg</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">checkQRStatus</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`/login/qr/check?key=<span class="subst">$&#123;key&#125;</span>&amp;timestamp=<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initQR</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取并验证session</span></span><br><span class="line">    sessionId = <span class="title function_">getSessionId</span>();</span><br><span class="line">    <span class="keyword">if</span> (!sessionId) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;status&#x27;</span>).<span class="property">textContent</span> = <span class="string">&#x27;无效的登录链接&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isValid = <span class="keyword">await</span> <span class="title function_">validateSession</span>(sessionId);</span><br><span class="line">    <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;status&#x27;</span>).<span class="property">textContent</span> = <span class="string">&#x27;登录链接已过期或无效&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key</span></span><br><span class="line">    key = <span class="keyword">await</span> <span class="title function_">getQRKey</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取二维码</span></span><br><span class="line">    <span class="keyword">const</span> qrimg = <span class="keyword">await</span> <span class="title function_">getQRCode</span>(key);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;qrImg&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;qrimg&#125;</span>&quot; /&gt;`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始轮询检查状态</span></span><br><span class="line">    <span class="title function_">checkStatus</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>状态监控</strong></li></ol><ul><li>定时轮询</li><li>自动跳转</li><li>错误提示</li></ul><h3 id="上传页面"><a href="#上传页面" class="headerlink" title="上传页面"></a>上传页面</h3><ol><li><strong>进度展示</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查上传状态</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">checkStatus</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> sessionId = <span class="title function_">getSessionId</span>();</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            <span class="attr">url</span>: <span class="string">`/newupload?time=<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>&amp;sessionId=<span class="subst">$&#123;sessionId&#125;</span>`</span>,</span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">                <span class="attr">operation</span>: <span class="string">&#x27;status&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">withCredentials</span>: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> status = response.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (status.<span class="property">status</span> === <span class="string">&#x27;uploading&#x27;</span>) &#123;</span><br><span class="line">            uploadStatus.<span class="property">textContent</span> = <span class="string">`正在上传: <span class="subst">$&#123;status.current&#125;</span>/<span class="subst">$&#123;status.total&#125;</span>`</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> progressItem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            progressItem.<span class="property">className</span> = <span class="string">&#x27;progress&#x27;</span>;</span><br><span class="line">            progressItem.<span class="property">textContent</span> = <span class="string">`当前文件: <span class="subst">$&#123;status.currentFile&#125;</span>`</span>;</span><br><span class="line">            progressList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            progressList.<span class="title function_">appendChild</span>(progressItem);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status.<span class="property">status</span> === <span class="string">&#x27;completed&#x27;</span>) &#123;</span><br><span class="line">            uploadStatus.<span class="property">textContent</span> = <span class="string">`上传完成！共处理 <span class="subst">$&#123;status.total&#125;</span> 个文件`</span>;</span><br><span class="line">            progressList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="title function_">stopStatusCheck</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status.<span class="property">status</span> === <span class="string">&#x27;idle&#x27;</span>) &#123;</span><br><span class="line">            uploadStatus.<span class="property">textContent</span> = <span class="string">&#x27;上传任务已停止&#x27;</span>;</span><br><span class="line">            progressList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="title function_">stopStatusCheck</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        uploadStatus.<span class="property">textContent</span> = <span class="string">&#x27;检查状态失败: &#x27;</span> + error.<span class="property">message</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>自动化处理</strong></li></ol><ul><li>登录检查</li><li>自动开始</li><li>实时更新</li></ul><h2 id="未来优化方向"><a href="#未来优化方向" class="headerlink" title="未来优化方向"></a>未来优化方向</h2><ol><li><strong>性能提升</strong></li></ol><ul><li>引入消息队列</li><li>并发上传</li><li>断点续传</li></ul><ol start="2"><li><strong>功能增强</strong></li></ol><ul><li>进度持久化</li><li>智能匹配</li><li>批量处理</li></ul><ol start="3"><li><strong>监控改进</strong></li></ol><ul><li>性能监控</li><li>错误追踪</li><li>用户反馈</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我开发了一个支持多用户批量上传到网易云盘的扩展功能模块，主要包括：批量音乐文件上传、音质选择（SQ/Hi-res）、自动与系统元数据信息匹配、会话管理系统。通过对多用户的&lt;strong&gt;session进行管理&lt;/strong&gt;，实现并行上传不同曲库；通过对&lt;strong&gt;网易云曲库元数据的读取&lt;/strong&gt;，创建了与本地音频的映射数据库，相比其他商家实现了0误差的歌曲匹配；在公网服务器与内网机器之间做&lt;strong&gt;内网穿透和nginx反向代理&lt;/strong&gt;，同时依托&lt;strong&gt;前后端分离&lt;/strong&gt;的设计思路，用户可以在公网访问上传服务。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="JavaScript" scheme="https://keyc.top/tags/JavaScript/"/>
    
    <category term="HTML" scheme="https://keyc.top/tags/HTML/"/>
    
    <category term="应用" scheme="https://keyc.top/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Tampermonkey浏览器脚本开发实践</title>
    <link href="https://keyc.top/Tampermonkey%E6%B5%8F%E8%A7%88%E5%99%A8%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <id>https://keyc.top/Tampermonkey%E6%B5%8F%E8%A7%88%E5%99%A8%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-10-31T07:18:09.000Z</published>
    <updated>2024-10-31T07:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在一些在线学习平台中，经常会遇到计时系统，用于记录学习时长。有时这些系统会有一些烦人的确认弹窗，比如每5分钟弹出一次确认框。本文将介绍如何通过修改JavaScript代码来优化这个体验。</p><span id="more"></span><h2 id="JavaScript计时器基础知识"><a href="#JavaScript计时器基础知识" class="headerlink" title="JavaScript计时器基础知识"></a>JavaScript计时器基础知识</h2><h3 id="1-浏览器中的计时器"><a href="#1-浏览器中的计时器" class="headerlink" title="1. 浏览器中的计时器"></a>1. 浏览器中的计时器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最基本的计时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>, milliseconds)  <span class="comment">// 持续重复执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>, milliseconds)   <span class="comment">// 延迟执行一次</span></span><br></pre></td></tr></table></figure><h3 id="2-计时器的工作原理"><a href="#2-计时器的工作原理" class="headerlink" title="2. 计时器的工作原理"></a>2. 计时器的工作原理</h3><ul><li>浏览器为每个计时器分配一个唯一ID</li><li>计时器在后台按指定间隔执行函数</li><li>可以通过<code>clearInterval()</code>清除计时器</li></ul><h2 id="修改网页脚本的三种方法"><a href="#修改网页脚本的三种方法" class="headerlink" title="修改网页脚本的三种方法"></a>修改网页脚本的三种方法</h2><h3 id="1-控制台直接修改（临时方案）"><a href="#1-控制台直接修改（临时方案）" class="headerlink" title="1. 控制台直接修改（临时方案）"></a>1. 控制台直接修改（临时方案）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 覆盖原有函数</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">_fresh</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 新的函数逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重启计时器</span></span><br><span class="line"><span class="title function_">_fresh</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(_fresh, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>简单直接</li><li>立即生效</li><li>适合测试和调试</li></ul><p>缺点：</p><ul><li>刷新页面后失效</li><li>需要每次手动执行</li></ul><h3 id="2-使用Tampermonkey（推荐方案）"><a href="#2-使用Tampermonkey（推荐方案）" class="headerlink" title="2. 使用Tampermonkey（推荐方案）"></a>2. 使用Tampermonkey（推荐方案）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         计时器修改</span></span><br><span class="line"><span class="comment">// @match        https://example.com/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">// 脚本内容</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>自动执行</li><li>持久化保存</li><li>可跨页面使用</li><li>便于管理和更新</li></ul><h2 id="网页源码分析"><a href="#网页源码分析" class="headerlink" title="网页源码分析"></a>网页源码分析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;/div&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">LANGUAGE</span>=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> secondsInit = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> hdflag = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> login_flag = <span class="string">&quot;1&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">_fresh</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">secondsInit ++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> seconds = secondsInit;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span> (seconds &gt;= <span class="number">3600</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> h = <span class="title class_">Math</span>.<span class="title function_">floor</span>(seconds / <span class="number">3600</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">result += h + <span class="string">&quot;小时&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">seconds -= <span class="number">3600</span> * h;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span> (seconds &gt;= <span class="number">60</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>(seconds / <span class="number">60</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">result += m + <span class="string">&quot;分&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">seconds -= <span class="number">60</span> * m;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">result += seconds + <span class="string">&quot;秒&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;_lefttime&#x27;</span>).<span class="property">innerHTML</span> = result;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span>((hdflag%<span class="number">60</span>)==<span class="number">0</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">$.<span class="title function_">post</span>(<span class="string">&quot;exam_xuexi_online.php&quot;</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="string">&quot;cmd&quot;</span>:<span class="string">&#x27;xuexi_online&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">data = <span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span>+data+<span class="string">&#x27;)&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span>(data.<span class="property">status</span>==<span class="number">1</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">$(<span class="string">&#x27;#xuexi_online&#x27;</span>).<span class="title function_">html</span>(data.<span class="property">shichang</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span>(hdflag&gt;<span class="number">300</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span>(<span class="title function_">confirm</span>(<span class="string">&quot;您已经在此页面5分钟了，是否继续？&quot;</span>))&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">hdflag = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">hdflag ++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">if</span>(login_flag)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">_fresh</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="built_in">setInterval</span>(_fresh,<span class="number">1000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="计时器核心功能"><a href="#计时器核心功能" class="headerlink" title="计时器核心功能"></a>计时器核心功能</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> secondsInit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> hdflag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> login_flag = <span class="string">&quot;1&quot;</span>;</span><br></pre></td></tr></table></figure><p>关键变量说明：</p><ul><li><code>secondsInit</code>: 记录总计时秒数</li><li><code>hdflag</code>: 用于触发确认框的计数器</li><li><code>login_flag</code>: 登录状态标志</li></ul><h3 id="计时器触发条件"><a href="#计时器触发条件" class="headerlink" title="计时器触发条件"></a>计时器触发条件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(login_flag)&#123;</span><br><span class="line">    <span class="title function_">_fresh</span>()</span><br><span class="line">    <span class="built_in">setInterval</span>(_fresh,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计时器启动条件：</p><ol><li>必须是登录状态（<code>login_flag</code> 为真）</li><li>页面加载完成后立即执行一次</li><li>之后每秒执行一次</li></ol><h3 id="代码执行时序"><a href="#代码执行时序" class="headerlink" title="代码执行时序"></a>代码执行时序</h3><ol><li>页面开始加载</li><li>DOM构建完成</li><li>jQuery初始化完成</li><li>检查登录状态</li><li>启动计时器</li><li>开始周期性执行</li></ol><h3 id="网络交互"><a href="#网络交互" class="headerlink" title="网络交互"></a>网络交互</h3><ul><li>使用jQuery的AJAX功能</li><li>每60秒向服务器同步一次学习时间</li><li>服务器返回JSON格式数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">shichang</span>: <span class="string">&quot;学习时长&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实战案例：修改计时确认框"><a href="#实战案例：修改计时确认框" class="headerlink" title="实战案例：修改计时确认框"></a>实战案例：修改计时确认框</h2><h3 id="修改后的代码"><a href="#修改后的代码" class="headerlink" title="修改后的代码"></a>修改后的代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_fresh</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 计时逻辑保持不变</span></span><br><span class="line">    <span class="keyword">if</span>(hdflag&gt;<span class="number">300</span>)&#123;</span><br><span class="line">        hdflag = <span class="number">0</span>;  <span class="comment">// 直接重置，不显示确认框</span></span><br><span class="line">    &#125;</span><br><span class="line">    hdflag++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-完整的Tampermonkey脚本"><a href="#3-完整的Tampermonkey脚本" class="headerlink" title="3. 完整的Tampermonkey脚本"></a>3. 完整的Tampermonkey脚本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         实验室安全教育计时修改</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      1.0</span></span><br><span class="line"><span class="comment">// @description  移除5分钟确认框</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        https://labsafetest.uestc.edu.cn/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// @run-at       document-end</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待页面和jQuery完全加载</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">waitForElements</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> $ !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; $(<span class="string">&#x27;#_lefttime&#x27;</span>).<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">initScript</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(waitForElements, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">initScript</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 定义新的_fresh函数</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">_fresh</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            secondsInit++;</span><br><span class="line">            <span class="keyword">var</span> seconds = secondsInit;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (seconds &gt;= <span class="number">3600</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> h = <span class="title class_">Math</span>.<span class="title function_">floor</span>(seconds / <span class="number">3600</span>);</span><br><span class="line">                result += h + <span class="string">&quot;小时&quot;</span>;</span><br><span class="line">                seconds -= <span class="number">3600</span> * h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (seconds &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>(seconds / <span class="number">60</span>);</span><br><span class="line">                result += m + <span class="string">&quot;分&quot;</span>;</span><br><span class="line">                seconds -= <span class="number">60</span> * m;</span><br><span class="line">            &#125;</span><br><span class="line">            result += seconds + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;_lefttime&#x27;</span>).<span class="property">innerHTML</span> = result;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((hdflag%<span class="number">60</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                $.<span class="title function_">post</span>(<span class="string">&quot;exam_xuexi_online.php&quot;</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;cmd&quot;</span>:<span class="string">&#x27;xuexi_online&#x27;</span></span><br><span class="line">                &#125;, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">                    data = <span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span>+data+<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(data.<span class="property">status</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                        $(<span class="string">&#x27;#xuexi_online&#x27;</span>).<span class="title function_">html</span>(data.<span class="property">shichang</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除确认框，直接重置计数器</span></span><br><span class="line">            <span class="keyword">if</span>(hdflag&gt;<span class="number">300</span>)&#123;</span><br><span class="line">                hdflag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hdflag++;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除所有可能存在的定时器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">9999</span>; i++) &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="built_in">clearInterval</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新启动计时器</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> login_flag !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; login_flag) &#123;</span><br><span class="line">            <span class="title function_">_fresh</span>();</span><br><span class="line">            <span class="built_in">setInterval</span>(_fresh, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动脚本</span></span><br><span class="line">    <span class="title function_">waitForElements</span>();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="技术要点解析"><a href="#技术要点解析" class="headerlink" title="技术要点解析"></a>技术要点解析</h2><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>window对象是全局作用域</li><li>使用var、let、const的区别</li><li>闭包的使用</li></ul><h3 id="定时器管理"><a href="#定时器管理" class="headerlink" title="定时器管理"></a>定时器管理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除所有定时器的技巧</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">9999</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">clearInterval</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="脚本上传与发布"><a href="#脚本上传与发布" class="headerlink" title="脚本上传与发布"></a>脚本上传与发布</h3><p><a href="https://greasyfork.org/zh-CN/script_versions/new">https://greasyfork.org/zh-CN/script_versions/new</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一些在线学习平台中，经常会遇到计时系统，用于记录学习时长。有时这些系统会有一些烦人的确认弹窗，比如每5分钟弹出一次确认框。本文将介绍如何通过修改JavaScript代码来优化这个体验。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="JavaScript" scheme="https://keyc.top/tags/JavaScript/"/>
    
    <category term="Tampermonkey" scheme="https://keyc.top/tags/Tampermonkey/"/>
    
    <category term="脚本" scheme="https://keyc.top/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>docker swarm网桥连接问题</title>
    <link href="https://keyc.top/docker-swarm%E7%BD%91%E6%A1%A5%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://keyc.top/docker-swarm%E7%BD%91%E6%A1%A5%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</id>
    <published>2024-09-09T12:37:33.000Z</published>
    <updated>2024-09-10T02:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>解决了平台worker node的容器连接docker swarm网桥的问题。</p><span id="more"></span><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol><li>Docker swarm网桥只能在manager node这个宿主机上建立。然而之前的代码，有可能发生在worker node上创建网桥的操作。</li><li>在manager节点上创建的swarm网桥，<strong>如果worker节点上没有容器连接到这个网桥，那么这个网桥不可见</strong>（命令行使用docker network ls不能找到），也就是说不能使用<code>client.networks.get(network_name)</code>获取网络对象，更不能通过<code>network.connect(container)</code>使容器连接到网桥。</li></ol><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>所有创建swarm网桥的操作都由master完成。</li><li>任何机器上的节点，无论是Ryu控制器还是普通节点，都可以连接到swarm网桥。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>根据之前代码的逻辑，动态添加节点时，创建overlay网络是在传入worker之后执行的，我不打算更改这个逻辑。</p><p>因此我添加了一个接口，在传入worker后调用，会向master发送一个请求，要求master来创建这个网桥。</p><p>在创建了网桥之后，由于worker上此时还是看不到这个网桥，需要使用低层次的api让容器连接到网桥。</p><p><code>client.api.connect_container_to_network(container_id, network_name)</code></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面是脚本1，也是平台之前连接docker swarm 网桥的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到Docker daemon</span></span><br><span class="line">client = docker.from_env()</span><br><span class="line"></span><br><span class="line"><span class="comment"># overlay网络的名称</span></span><br><span class="line">network_name = <span class="string">&#x27;mynetwork&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要连接的容器ID或名称</span></span><br><span class="line">container_name = <span class="string">&#x27;my_existing_container&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 获取网络对象</span></span><br><span class="line">    network = client.networks.get(network_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取容器对象</span></span><br><span class="line">    container = client.containers.get(container_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将容器连接到网络</span></span><br><span class="line">    network.connect(container)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Successfully connected container <span class="subst">&#123;container_name&#125;</span> to network <span class="subst">&#123;network_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> docker.errors.NotFound <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> docker.errors.APIError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;API Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>下面是脚本2，是使用更低级别api连接网桥的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到Docker daemon</span></span><br><span class="line">client = docker.from_env()</span><br><span class="line"></span><br><span class="line"><span class="comment"># overlay网络的名称</span></span><br><span class="line">network_name = <span class="string">&#x27;test-br&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要连接的容器ID或名称</span></span><br><span class="line">container_name = <span class="string">&#x27;6475a6cb8ae59383&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果数据库中有，可以直接传入这个id，不行的话也可以用client.containers.get获得</span></span><br><span class="line">container_id = <span class="string">&#x27;2ea581519a31&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 获取容器对象</span></span><br><span class="line">    <span class="comment"># container = client.containers.get(container_name)</span></span><br><span class="line">    <span class="comment"># container_id = container.id</span></span><br><span class="line">    <span class="comment"># 使用低级API直接连接容器到网络</span></span><br><span class="line">    client.api.connect_container_to_network(container_id, network_name)</span><br><span class="line">    <span class="comment"># client.api.disconnect_container_from_network(container_id, network_name)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Successfully connected container <span class="subst">&#123;container_id&#125;</span> to network <span class="subst">&#123;network_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> docker.errors.NotFound <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: Container or network not found - <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> docker.errors.APIError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;API Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><blockquote><p>self.container = docker_cli.containers.get(info[‘NEid’])<br>通过这种方式，这个info[‘NEid’]和container_id一样吗</p></blockquote><ol><li><p><code>container_id</code> 和 <code>info[&#39;NEid&#39;]</code> 可能相同，也可能不同，这取决于 <code>info[&#39;NEid&#39;]</code> 中存储的是什么。</p></li><li><p>Docker 容器可以通过几种不同的方式来标识：</p><ul><li>完整的容器 ID（64 个字符的长字符串）</li><li>短 ID（通常是完整 ID 的前 12 个字符）</li><li>容器名称</li></ul></li><li><p><code>docker_cli.containers.get()</code> 方法很灵活，它可以接受以上任何一种标识方式。</p></li></ol><p>所以，<code>info[&#39;NEid&#39;]</code> 可能是：</p><ul><li>完整的容器 ID</li><li>短 ID</li><li>容器名称</li></ul><p>为了确认和比较，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设您之前已经有了 container_id</span></span><br><span class="line">container_id = ...  <span class="comment"># 之前获取的完整容器 ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 info[&#x27;NEid&#x27;] 获取容器</span></span><br><span class="line"><span class="variable language_">self</span>.container = docker_cli.containers.get(info[<span class="string">&#x27;NEid&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较 ID</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Original container_id: <span class="subst">&#123;container_id&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;info[&#x27;NEid&#x27;]: <span class="subst">&#123;info[<span class="string">&#x27;NEid&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Retrieved container ID: <span class="subst">&#123;self.container.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Retrieved container short ID: <span class="subst">&#123;self.container.short_id&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Retrieved container name: <span class="subst">&#123;self.container.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否是同一个容器</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable language_">self</span>.container.<span class="built_in">id</span> == container_id:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s the same container&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s a different container&quot;</span>)</span><br></pre></td></tr></table></figure><p>几点注意：</p><ol><li><code>self.container.id</code> 总是返回完整的容器 ID。</li><li><code>self.container.short_id</code> 返回短 ID（通常是前 12 个字符）。</li><li><code>self.container.name</code> 返回容器的名称。</li></ol><p>如果 <code>info[&#39;NEid&#39;]</code> 存储的是有效的容器标识符（无论是 ID 还是名称），<code>docker_cli.containers.get()</code> 都会返回正确的容器对象。这个对象的 <code>id</code> 属性将始终是完整的容器 ID，无论用于获取容器的标识符是什么。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;解决了平台worker node的容器连接docker swarm网桥的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="docker" scheme="https://keyc.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Git:多机器多仓库代码同步</title>
    <link href="https://keyc.top/Git-%E5%A4%9A%E6%9C%BA%E5%99%A8%E5%A4%9A%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5/"/>
    <id>https://keyc.top/Git-%E5%A4%9A%E6%9C%BA%E5%99%A8%E5%A4%9A%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5/</id>
    <published>2024-07-24T08:05:50.000Z</published>
    <updated>2024-07-24T08:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>平台的代码在多个机器上同时运行，在master上修改了代码，希望worker也可以方便地更新。</p><p>还是使用git实现，两个仓库连接到同一个远程仓库的同一个分支。</p><span id="more"></span><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>将原仓库的文件复制到另一个机器上，当然也可以之后fetch。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r &lt;user&gt;@192.168.1.124:/home/path/dir ./</span><br></pre></td></tr></table></figure><p>初始化git。注意：初始化的时候，不要在root用户，不然之后vscode访问或者ssh都有可能不通。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@gitee.com:uestc-minenet/vemu_uestc.git</span><br><span class="line">git config user.name <span class="string">&quot;kxxxcxxx&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;1xxxxxxxxx@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>私钥公钥设置：因为我想在多个机器上使用同一个私钥连接到远程仓库，所以需要把原机器使用的私钥，复制到新的机器上（如果是root用户使用scp复制的私钥，也会导致私钥在其他用户时不可用）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp &lt;user&gt;@192.168.1.124:/home/&lt;user&gt;/.ssh/id_rsa ./</span><br></pre></td></tr></table></figure><p>经过反复调试发现，原仓库的私钥不在<code>~/.ssh</code>目录下，而是在<code>/home/&lt;user&gt;/.ssh</code>目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure><blockquote><p>Hi Admin(@uestc-minenet_0)! You’ve successfully authenticated, but GITEE.COM does not provide shell access.</p></blockquote><p>如果上一步骤不能联通，可能有以下几种原因：</p><ol><li>ssh私钥错误：位置错误、内容错误、命名有误、权限不够。</li><li>网络故障，如果不能ping通gitee.com，可以检查DNS，<code>/etc/resolv.conf</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>此时会列举出目前的所有分支：</p><blockquote><p>Receiving objects: 100% (10110/10110), 39.12 MiB | 2.01 MiB/s, done.<br>Resolving deltas: 100% (6521/6521), done.<br>From gitee.com:uestc-minenet/vemu_uestc</p><ul><li>[new branch]      develop                             -&gt; origin/develop</li><li>[new branch]      feature/sat-dev                     -&gt; origin/feature/sat-dev</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature/sat-dev origin/feature/sat-dev</span><br></pre></td></tr></table></figure><p>此时，应该显示的就是你想要同步的分支了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;平台的代码在多个机器上同时运行，在master上修改了代码，希望worker也可以方便地更新。&lt;/p&gt;
&lt;p&gt;还是使用git实现，两个仓库连接到同一个远程仓库的同一个分支。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://keyc.top/tags/git/"/>
    
    <category term="linux" scheme="https://keyc.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>博客维护之修复加载页面过慢的问题</title>
    <link href="https://keyc.top/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4%E4%B9%8B%E4%BF%AE%E5%A4%8D%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E8%BF%87%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://keyc.top/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4%E4%B9%8B%E4%BF%AE%E5%A4%8D%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E8%BF%87%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-07-20T18:51:11.000Z</published>
    <updated>2024-07-22T12:14:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>作为学习网络的人，致力于解决我遇到的所有网络卡顿的问题，终于能除一除身边的”杂草“了。</p><span id="more"></span><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>在开发者工具打开的情况下刷新页面，以捕获所有的网络请求。</p><p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240721025634659.png" alt="image-20240721025634659"></p><p>发现在加载了一些请求后，要卡顿30s，然后才能显示网页，在此之前几乎是空白的。</p><p>在显示网页之前，会有一个请求报错，显示没有响应。</p><p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240721025845686.png" alt="image-20240721025845686"></p><p>我自己在浏览器中试了下，发现它 <a href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css</a> 确实没有响应。</p><p><a href="https://blog.csdn.net/m0_57767508/article/details/124915932">查找资料</a>，只需要将所有<code>cdn.jsdelivr.net</code> 更换为<code> fastly.jsdelivr.net</code>。</p><p>在本地的public文件夹下，查看所有渲染好的页面，发现所有页面都需要发送这个请求，所以我需要替换一下所有页面的这个字段。</p><blockquote><p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240722173900111.png"></p><p>可以看到，目前的解决方法有个bug：上面的截图中是本地md的显示，然而在渲染之后的html中正文中的内容也被替换掉了。暂时不管它了。</p></blockquote><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>我创建了一个 Hexo 插件来在生成过程中修改 HTML 内容。</p><p>在 Hexo 项目根目录下创建  <code>scripts/cdn_replace.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_render:html&#x27;</span>, <span class="keyword">function</span>(<span class="params">str, data</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/cdn\.jsdelivr\.net/g</span>, <span class="string">&#x27;fastly.jsdelivr.net&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个插件会在 HTML 渲染后替换所有的 CDN 链接。</p><blockquote><p>这个 JavaScript 文件会被 Hexo 自动调用。这是因为 Hexo 有一个特殊的约定来处理插件和脚本。以下是详细解释：</p><ol><li>自动加载机制：<br>Hexo 会自动加载项目根目录下 <code>scripts</code> 文件夹中的所有 JavaScript 文件。这是 Hexo 的一个内置功能，用于扩展和自定义 Hexo 的行为。</li><li>脚本执行时机：<br>这些脚本在 Hexo 初始化时就会被执行，这意味着它们可以用来注册新的扩展、过滤器、辅助函数等。</li><li>过滤器注册：<br>在提供的示例中，我们使用 <code>hexo.extend.filter.register()</code> 方法注册了一个新的过滤器。这个方法告诉 Hexo 在特定的事件（在这个例子中是 ‘after_render:html’）发生时执行我们的函数。</li><li>事件触发：<br>当 Hexo 渲染 HTML 文件后，它会触发 ‘after_render:html’ 事件，此时我们注册的函数就会被调用，执行替换操作。</li><li>无需显式调用：<br>由于这个脚本是被 Hexo 自动加载和执行的，你不需要在任何地方显式地调用它。只要将文件放在正确的位置（<code>scripts</code> 文件夹中），Hexo 就会处理剩下的事情。</li><li>热重载：<br>在开发过程中，当你修改了 <code>scripts</code> 文件夹中的文件后，Hexo 会在下一次生成时自动重新加载这些脚本。</li><li>优先级：<br><code>scripts</code> 文件夹中的脚本优先级高于插件，这意味着你可以用这种方式覆盖或修改插件的行为。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为学习网络的人，致力于解决我遇到的所有网络卡顿的问题，终于能除一除身边的”杂草“了。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="javascript" scheme="https://keyc.top/tags/javascript/"/>
    
    <category term="html" scheme="https://keyc.top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Satellite network emulation By STORM</title>
    <link href="https://keyc.top/Satellite-network-emulation-By-STORM/"/>
    <id>https://keyc.top/Satellite-network-emulation-By-STORM/</id>
    <published>2024-07-20T14:21:25.000Z</published>
    <updated>2024-07-20T18:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a href="https://storm.genie.stanford.edu/article/satellite-network-emulation-24757">https://storm.genie.stanford.edu/article/satellite-network-emulation-24757</a></p><p>这是使用网页搜索+GPT生成文章的一个工具，针对卫星网络模拟平台这个主题对它进行了简单的测试，效果不错。</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://storm.genie.stanford.edu/article/satellite-network-emulation-24757&quot;&gt;https://storm.genie.stanford.edu/article/satellite-network-emulation-24757&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是使用网页搜索+GPT生成文章的一个工具，针对卫星网络模拟平台这个主题对它进行了简单的测试，效果不错。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="网络" scheme="https://keyc.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="卫星网络模拟" scheme="https://keyc.top/tags/%E5%8D%AB%E6%98%9F%E7%BD%91%E7%BB%9C%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="AI工具" scheme="https://keyc.top/tags/AI%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>《Scaling Open vSwitch with a Computational Cache》阅读笔记</title>
    <link href="https://keyc.top/%E3%80%8AScaling%20Open%20vSwitch%20with%20a%20Computational%20Cache%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://keyc.top/%E3%80%8AScaling%20Open%20vSwitch%20with%20a%20Computational%20Cache%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-20T03:36:48.000Z</published>
    <updated>2024-04-20T04:02:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文摘要：</p><p>Open vSwitch（OVS）是一种广泛使用的开源虚拟交换机实现。在这项工作中，我们试图通过<strong>加速其数据路径的核心组件——包分类机制</strong>，来扩展OVS以支持数十万条OpenFlow规则。为此，我们使用了NuevoMatch，这是一种利用神经网络推理进行数据包匹配的最新算法，它承诺具有显著的<strong>可扩展性</strong>和性能优势。我们克服了原始NuevoMatch中更新规则速度慢的主要算法挑战，将其速度提高了超过三个数量级。这一改进使得将NuevoMatch与OVS集成成为可能，提供了两种设计选项：（1）将其作为OVS的<strong>megaflow缓存前的额外缓存层</strong>；（2）用它<strong>完全替代OVS的数据路径</strong>，直接对OpenFlow规则进行分类，避免了对控制路径的调用。我们对真实世界的数据包追踪和1K至500K的ClassBench规则进行了全面评估，结果显示，在500K规则的情况下，第一种设计和第二种设计分别实现了1.9倍和12.3倍的几何平均速度提升，后者还支持每秒高达60K OpenFlow规则的更新，远远超过了原始OVS的性能。</p><span id="more"></span><h2 id="文章综述"><a href="#文章综述" class="headerlink" title="文章综述"></a>文章综述</h2><h3 id="作者信息"><a href="#作者信息" class="headerlink" title="作者信息"></a>作者信息</h3><p><a href="https://alonrashelbach.com/">Alon Rashelbach</a></p><p>以色列理工学院的一名博士，他的这个工作先是发表在了nsdi22，然后增加了一些公式之后，发表在了ToN期刊上。他在今年的nsdi，也是继续延续可编程网络交换机的方向发表了新的文章。</p><p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240420114946396.png" alt="image-20240420114946396"></p><h2 id="文章资源"><a href="#文章资源" class="headerlink" title="文章资源"></a>文章资源</h2><p><a href="https://www.usenix.org/conference/nsdi22/presentation/rashelbach">Scaling Open vSwitch with a Computational Cache | USENIX</a></p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="Megaflow条目过多"><a href="#Megaflow条目过多" class="headerlink" title="Megaflow条目过多"></a>Megaflow条目过多</h3><p>为了维护非重叠megaflow条目，即使面对少量的、但是条件细化的OpenFlow规则，OVS也可能需要生成大量的megaflow条目。这不仅增加了数据路径处理的复杂度，还可能影响性能，尤其是在需要频繁更新规则的环境下。这种增加的复杂度和可能的性能影响正是引入如OVS-CFLOWS这样的优化策略的原因之一。</p><h3 id="DPDK的Data-path是干什么的？"><a href="#DPDK的Data-path是干什么的？" class="headerlink" title="DPDK的Data-path是干什么的？"></a>DPDK的Data-path是干什么的？</h3><p>TODO</p><h3 id="Iset设计"><a href="#Iset设计" class="headerlink" title="Iset设计"></a>Iset设计</h3><p>iSet的设计允许将传统的流量规则集转化为一组经过优化的、易于神经网络处理的规则子集</p><h3 id="SIMD在NuevoMatch中的应用"><a href="#SIMD在NuevoMatch中的应用" class="headerlink" title="SIMD在NuevoMatch中的应用"></a>SIMD在NuevoMatch中的应用</h3><p>文章中通过使用SIMD指令集来优化NuevoMatch算法，主要是为了提升神经网络模型的训练和推理速度。在NuevoMatch算法中，神经网络模型用于学习网络流量规则的分布，并快速定位数据包应该匹配的规则。利用SIMD可以加速神经网络中的多个数学运算，如矩阵乘法、激活函数计算等：</p><ul><li><strong>加速矩阵运算</strong>：神经网络的前向传播和反向传播算法中包含大量的矩阵运算，使用SIMD可以同时计算矩阵中的多个元素，从而加速整个网络的计算过程。</li><li><strong>提高数据吞吐量</strong>：通过并行处理多个数据点，SIMD能够提高处理器对数据的吞吐量，使算法能够更快地处理大量的网络流量数据。</li><li><strong>优化计算资源使用</strong>：利用SIMD指令集可以更有效地利用处理器资源，提高计算密集型任务的执行效率，从而在不增加额外硬件成本的情况下提升性能。</li></ul><h3 id="作者提供的benchmark工具"><a href="#作者提供的benchmark工具" class="headerlink" title="作者提供的benchmark工具"></a>作者提供的benchmark工具</h3><p><a href="https://alonrashelbach.com/2021/12/20/benchmarking-packet-classification-algorithms/">Benchmarking Packet Classification Algorithms – Alon Rashelbach</a></p><p>他们使用这些工具进行的文章中的实验。</p><h3 id="规则重叠"><a href="#规则重叠" class="headerlink" title="规则重叠"></a>规则重叠</h3><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240420115153097.png" alt="image-20240420115153097" style="zoom: 33%;" /><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240420115220743.png" alt="image-20240420115220743" style="zoom:33%;" /><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240420115242048.png" alt="image-20240420115242048" style="zoom:33%;" /><h3 id="OvS-datapath"><a href="#OvS-datapath" class="headerlink" title="OvS datapath"></a>OvS datapath</h3><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240420115323884.png" alt="image-20240420115323884" style="zoom: 67%;" /><h3 id="RMI-递归模型索引"><a href="#RMI-递归模型索引" class="headerlink" title="RMI 递归模型索引"></a>RMI 递归模型索引</h3><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240420115345804.png" alt="image-20240420115345804" style="zoom:33%;" /><h2 id="从这篇文章的收获"><a href="#从这篇文章的收获" class="headerlink" title="从这篇文章的收获"></a>从这篇文章的收获</h2><ol><li>通过读这篇文章，我们可以对OvS的内部工作机制如数据通路有更深的理解，发现OvS可能的性能瓶颈。</li><li>证明一种优化路径的可行性，就是通过实时迅速训练人工智能模型，来更快速地获得结果。学习到如何利用机器学习技术，特别是神经网络，来解决网络流量分类和管理的问题。</li><li>同时，文章中展示了两种设计思路，可以启发我们思考如何在追求高性能的，同时保持系统的灵活性和可扩展性。</li><li>可以借鉴它如何从一个工作延申下去，从ovs到P4</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文摘要：&lt;/p&gt;
&lt;p&gt;Open vSwitch（OVS）是一种广泛使用的开源虚拟交换机实现。在这项工作中，我们试图通过&lt;strong&gt;加速其数据路径的核心组件——包分类机制&lt;/strong&gt;，来扩展OVS以支持数十万条OpenFlow规则。为此，我们使用了NuevoMatch，这是一种利用神经网络推理进行数据包匹配的最新算法，它承诺具有显著的&lt;strong&gt;可扩展性&lt;/strong&gt;和性能优势。我们克服了原始NuevoMatch中更新规则速度慢的主要算法挑战，将其速度提高了超过三个数量级。这一改进使得将NuevoMatch与OVS集成成为可能，提供了两种设计选项：（1）将其作为OVS的&lt;strong&gt;megaflow缓存前的额外缓存层&lt;/strong&gt;；（2）用它&lt;strong&gt;完全替代OVS的数据路径&lt;/strong&gt;，直接对OpenFlow规则进行分类，避免了对控制路径的调用。我们对真实世界的数据包追踪和1K至500K的ClassBench规则进行了全面评估，结果显示，在500K规则的情况下，第一种设计和第二种设计分别实现了1.9倍和12.3倍的几何平均速度提升，后者还支持每秒高达60K OpenFlow规则的更新，远远超过了原始OVS的性能。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="网络虚拟化" scheme="https://keyc.top/tags/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="论文笔记" scheme="https://keyc.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="OvS" scheme="https://keyc.top/tags/OvS/"/>
    
  </entry>
  
  <entry>
    <title>《程序员的README》</title>
    <link href="https://keyc.top/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84README%E3%80%8B/"/>
    <id>https://keyc.top/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84README%E3%80%8B/</id>
    <published>2024-04-01T12:44:39.000Z</published>
    <updated>2025-01-03T13:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>技术很重要，但是技术之外的东西更容易被看到，也更容易被忽视，对于新入行的新手来说，如果只读一本书，当然是这个Readme。从开发到测试，从交付到如何背锅，到如何去讨论问题，与人交流。</p><p>从技术的具体实践中抽象出通用的工作和生活原则。</p><span id="more"></span><h2 id="重要观点"><a href="#重要观点" class="headerlink" title="重要观点"></a>重要观点</h2><p>想象一下，你正在建造一座桥梁。这座桥梁的每一块砖都是一个决策，每一滴水泥都是一行代码。《程序员的README》教你如何挑选最坚固的砖块和最持久的水泥，让你的桥梁能够经受时间的考验。</p><p>首先，书中提到的“发布错误的答案来得到正确答案”策略，是一种巧妙地说明在互联网上，挑战和错误往往能激发群体智慧，找到正确解答的方法。就像在社交媒体上故意发布一张照片中的小错误，引发大家的注意和讨论，最终使得更多的焦点聚集在这张照片上。</p><p>自行车棚效应，则像是在建造房子时，大家都在争论应该使用哪种颜色的油漆来粉刷车库，却忽略了更为重要的结构安全问题。它提醒我们，在面对问题时，不应过分沉迷于细节，而是要看到问题的全貌。</p><p>关于技能的四个层次，可以想象成学习骑自行车的过程。最初，你甚至不知道自己为何会摔倒（无意识的无能力）；然后，你开始意识到是因为失去平衡（有意识的无能力）；接着，你通过刻意练习，能够在专注下保持平衡（有意识的有能力）；最后，骑车成为你的第二天性，你甚至可以在不经意间避开障碍物（无意识的有能力）。</p><p>对于软件开发者而言，理解自己工作的影响，阅读并学习优秀的代码，合理安排研究时间，勇于向他人求助，以及在团队中共享知识和经验，都是职业成长的重要部分。这些原则同样适用于许多其他领域的专业人士。</p><p>将这些技术原则翻译成生活中的智慧，我们可以学会更好地解决问题、合理安排时间、勇于向他人学习，并且不断地提高自己的能力。无论是编写代码，还是面对生活中的挑战，《程序员的README》提供的指导原则，都能帮助我们建立起一种更为有效和高效的解决问题的方法论。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将《程序员的README》中的经验扩展到各行各业，就是要从技术的具体实践中抽象出通用的工作和生活原则，让不同领域的专业人士也能受益。</p><h3 id="1-错误反馈机制：拥抱错误，以促进成长"><a href="#1-错误反馈机制：拥抱错误，以促进成长" class="headerlink" title="1. 错误反馈机制：拥抱错误，以促进成长"></a>1. <strong>错误反馈机制：拥抱错误，以促进成长</strong></h3><p>在互联网上故意发布错误答案以获得正确解答的策略，不仅适用于编程问题。在任何行业中，通过展示自己的工作成果并开放接受反馈，我们能够从他人的视角发现问题和改进的空间。这就如同在设计一款新产品时故意留下一些小“瑕疵”，邀请用户进行反馈，以此来迅速定位并解决真正重要的问题。</p><h3 id="2-自行车棚效应：专注于真正重要的事"><a href="#2-自行车棚效应：专注于真正重要的事" class="headerlink" title="2. 自行车棚效应：专注于真正重要的事"></a>2. <strong>自行车棚效应：专注于真正重要的事</strong></h3><p>过度关注细枝末节而忽视了问题的本质，在任何行业都是一个常见误区。比如在商业策划会议中，团队可能会在无关紧要的细节上争论不休，而忽略了核心的商业策略。认识到这一点，能帮助我们在面对决策时，将注意力集中在真正能带来变化的因素上。</p><h3 id="3-技能的四个层次：自我认知与持续进步"><a href="#3-技能的四个层次：自我认知与持续进步" class="headerlink" title="3. 技能的四个层次：自我认知与持续进步"></a>3. <strong>技能的四个层次：自我认知与持续进步</strong></h3><p>无论是在学习新的技能，还是在工作中提升自己，了解自己在技能掌握上的位置（无意识的无能力到无意识的有能力）对于个人成长至关重要。这一框架不仅适用于技术领域，比如编程，也同样适用于如销售、管理等非技术领域。它教会我们如何通过反思和实践，逐步提高自我效能和专业技能。</p><h3 id="4-实践胜于空谈：动手实践的力量"><a href="#4-实践胜于空谈：动手实践的力量" class="headerlink" title="4. 实践胜于空谈：动手实践的力量"></a>4. <strong>实践胜于空谈：动手实践的力量</strong></h3><p>在软件开发中，实际编写并发布代码是学习的重要一环。同样，在其他行业中，比如营销或产品设计，真正将理论付诸实践，通过实际操作和试错，往往能获得比仅仅理论学习更深刻的见解。实践是检验真理的唯一标准，通过实际动手，我们能够更加深入地理解理论，发现问题，并学习如何解决问题。</p><h3 id="5-合理规划研究与学习时间"><a href="#5-合理规划研究与学习时间" class="headerlink" title="5. 合理规划研究与学习时间"></a>5. <strong>合理规划研究与学习时间</strong></h3><p>设定时间限制并在必要时寻求帮助的建议，提示我们在任何任务或项目上，都应当合理安排时间和资源。无论是进行市场研究、新产品设计，还是学习新的技能，合理的时间管理和知道何时寻求外部帮助，是提高效率和质量的关键。</p><h3 id="6-跨领域学习：拓宽知识视野"><a href="#6-跨领域学习：拓宽知识视野" class="headerlink" title="6. 跨领域学习：拓宽知识视野"></a>6. <strong>跨领域学习：拓宽知识视野</strong></h3><p>软件开发者被鼓励阅读高质量的开源项目和代码库。这一建议同样适用于其他行业的专业人士。例如，设计师可以研究其他设计师的作品，市场专家可以研究成功的营销案例，企业家可以学习其他成功企业的商业模式。跨领域学习不仅能帮助我们发现新的灵感和方法，还能让我们避免重复他人的错误。</p><p>通过以上原则的扩展，看到《程序员的README》中的建议其实是一种思维方式和解决问题的方法，这些方法在任何行业中都是通用的。无论我们的职业背景如何，通过学习和实践这些原则，我们都能在自己的专业领域内实现更快的成长和更大的成功。</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><p>2024年3月31日</p><p>在互联网上获得正确答案的最好方法并不是提出问题，而是发布错误的答案</p><p>2024年3月31日</p><p><strong>过度集中在细枝末节上的讨论总是会很冗长，这种现象被称为“自行车棚”(bike-shedding)效应</strong></p><p>自行车棚效应</p><p>2024年3月31日</p><p><strong>无意识的无能力意味着你无法胜任某项任务，并且没有意识到这种差距。有意识的无能力意味着你虽然无法胜任某项任务，但其实已经意识到了其中的差距。有意识的有能力意味着你有能力通过努力完成某项任务。最后，无意识的有能力意味着你可以很轻松地胜任某项任务。</strong></p><p>2024年3月31日</p><p>在实践中学到的东西要比只坐在那里单纯地阅读学到的多出许多。你应该上手编写并且发布代码。第一次发布代码很可怕</p><p>2024年3月31日</p><p>尽你所能去理解你的工作会造成的影响，并以适当的谨慎程度行事。与变更高流量数据库上的索引相比，编写单元测试可以不那么谨慎，从而更快。</p><p>2024年3月31日</p><p>不要只读你自己的代码库，还要去阅读高质量的开源项目，特别是那些你使用的类库。不要像阅读小说一样从前到后地通读代码：请利用你的IDE来浏览代码。为关键的操作绘制控制流和状态图。仔细研究代码的数据结构和算法。注意那些临界值的处理。留意那些惯用写法和风格</p><p>2024年3月31日</p><p><strong>在你开始研究之前就应该设定好时间限制，这样可以鼓励你遵守这个限制，防止收益递减（研究最终会拖累生产性）</strong></p><p>2024年3月31日</p><p><strong>一旦你到达了设定的时间限制，就需要请人帮忙。只有在你取得良好进展的情况下才可以超过之前的时间限制。如果你已经超过了第一个时间限制，那么需要再设定一个</strong></p><p>2024年3月31日</p><p>第二个例子非常简洁，但又附有详细的信息，所以艾丽斯不需要主动去捕获这个问题</p><p>2024年3月31日</p><p>批量处理你的同步请求</p><p>2024年3月31日</p><p>聊天和电子邮件对简单的问题很实用，但复杂的讨论很难异步进行</p><p>2024年3月31日</p><p>尽管有着杰出的学术和职业成就，经历着冒充者现象的女性仍然坚持认为她们真的不聪明，而且还愚弄了任何不这么想的人。众多的成就似乎并不影响冒充者的信念，而这些成就本身就是能充分证明智力水平卓越的客观证据。</p><p>2024年3月31日</p><p>技术债甚至可能是成功的标志：项目只有存活了足够长的时间，才会变得无序。</p><p>2024年3月31日</p><p>所谓重构，是指在不改变软件行为的情况下改进内部代码结构。它经常发生在添加新特性的时候，因为它使新特性可以更容易地被添加。而在修复bug的过程中，则经常删除代码。</p><p>2024年3月31日</p><p>测试点是你想要修改的代码的入口，也就是测试用例需要调用和注入的区域。测试点揭示了代码在被你变更之前的行为，你需要使用这些测试点来测试你自己的变更。</p><p>2024年3月31日</p><p>当你在写代码的时候，简略地提交信息并没有错，但对其他人来说，这些信息是没有价值的。重置你的分支，压缩你的提交，并在提交代码修改供评审之前写一份清晰的提交信息。</p><p>2024年3月31日</p><p>尽可能地使用内置的异常，避免创建通用的异常。使用异常处理来应对故障，而不是控制应用程序的运行逻辑。</p><p>什么是内置的异常</p><p>2024年3月31日</p><p>“早抛”意味着在尽可能接近错误的地方引发异常，这样开发人员就能迅速地定位相关的代码。</p><p>同时，避免执行其他代码</p><p>2024年3月31日</p><p>“晚捕”意味着在调用的堆栈上传播这个异常，直到你到达能够处理异常的程序的层级。</p><p>2024年3月31日</p><p>当调用可能抛出异常的代码时，要么完全地处理它们，要么将它们在堆栈中进行传播。</p><p>“能够在上述选择中做出决定的代码段很可能与遇到磁盘已满情况的底层类库中间相差了好几层，所有的中间层都需要将异常向上传播，而不是试图过早地进行补救处理。最糟糕的过早补救是“吞下”一个你无法处理的异常，这通常表现为catch代码块会自行忽略它”</p><p>2024年3月31日</p><p>处理重试的最好方法是构建幂等系统</p><p>2024年3月31日</p><p>Python的with语句会在调用路径离开代码块时自动关闭句柄</p><p>“当故障发生后，要确保清理所有的资源，释放你不再需要的内存、数据结构、网络套接字和文件句柄”</p><p>2024年3月31日</p><p>并写出描述性的提交信息，务必将注释和测试包括在内</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;技术很重要，但是技术之外的东西更容易被看到，也更容易被忽视，对于新入行的新手来说，如果只读一本书，当然是这个Readme。从开发到测试，从交付到如何背锅，到如何去讨论问题，与人交流。&lt;/p&gt;
&lt;p&gt;从技术的具体实践中抽象出通用的工作和生活原则。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="总结" scheme="https://keyc.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="书评" scheme="https://keyc.top/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>SDN控制器Ryu的动态拓扑发现</title>
    <link href="https://keyc.top/SDN%E6%8E%A7%E5%88%B6%E5%99%A8Ryu%E6%8B%93%E6%89%91%E5%8F%91%E7%8E%B0%E6%A8%A1%E5%9D%97/"/>
    <id>https://keyc.top/SDN%E6%8E%A7%E5%88%B6%E5%99%A8Ryu%E6%8B%93%E6%89%91%E5%8F%91%E7%8E%B0%E6%A8%A1%E5%9D%97/</id>
    <published>2024-03-30T15:46:16.000Z</published>
    <updated>2024-04-12T08:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文介绍了如何使用SDN控制器Ryu进行动态网络拓扑的发现和监控。</p><p>通过实现一个名为<code>SimpleTopologyPrinter</code>的应用，展示了监控网络拓扑变化的基本方法，包括如何捕捉链路的添加和删除事件。实验中修改OvS交换机间的链路，观察到了Ryu对这些变化的响应，发现了链路添加事件有时会延迟反映的问题。本文还解释了Ryu的<code>hub.spawn</code>函数及其基于协程的并发特性，这些特性允许应用高效地处理多任务。最后，通过构建一个自定义应用，展示了如何利用Ryu维护和更新网络拓扑结构，确保拓扑信息的实时准确全面。本文为学习Openflow协议和Ryu编写规范提供了实用的经验和示例。</p><span id="more"></span><h2 id="网络拓扑打印应用"><a href="#网络拓扑打印应用" class="headerlink" title="网络拓扑打印应用"></a>网络拓扑打印应用</h2><p>一个简单的网络拓扑打印应用，名为<code>SimpleTopologyPrinter</code>，定期监控和打印当前网络拓扑的链接信息。</p><p>我在运行这个程序的时候，更改OvS交换机之间的veth-pair链路，可以观察到明显的<code>EventLinkDelete</code>，但是可能要间隔几十秒才能观察到<code>EventLinkAdd</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ryu.base <span class="keyword">import</span> app_manager</span><br><span class="line"><span class="keyword">from</span> ryu.topology <span class="keyword">import</span> event, switches</span><br><span class="line"><span class="keyword">from</span> ryu.controller.handler <span class="keyword">import</span> set_ev_cls</span><br><span class="line"><span class="keyword">from</span> ryu.lib <span class="keyword">import</span> hub</span><br><span class="line"><span class="keyword">from</span> ryu.topology.api <span class="keyword">import</span> get_link</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleTopologyPrinter</span>(app_manager.RyuApp):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(SimpleTopologyPrinter, <span class="variable language_">self</span>).__init__(*args, **kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.topology_api_app = <span class="variable language_">self</span></span><br><span class="line">        <span class="variable language_">self</span>.monitor_thread = hub.spawn(<span class="variable language_">self</span>._monitor_topology)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_monitor_topology</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            links = get_link(<span class="variable language_">self</span>.topology_api_app, <span class="literal">None</span>)</span><br><span class="line">            <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Current topology links:&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">                <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Link: %s&quot;</span>, link.to_dict())</span><br><span class="line">            <span class="variable language_">self</span>.logger.info(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line">            hub.sleep(<span class="number">20</span>)  <span class="comment"># Sleep for 20 second</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventLinkAdd</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">link_add_handler</span>(<span class="params">self, ev</span>):</span><br><span class="line">        <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Link added: %s&quot;</span>, ev.link.to_dict())</span><br><span class="line"></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventLinkDelete</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">link_delete_handler</span>(<span class="params">self, ev</span>):</span><br><span class="line">        <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Link deleted: %s&quot;</span>, ev.link.to_dict())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>self.logger.info</code>来记录链路信息和事件，可以在Ryu命令行打印内容。</p><h3 id="hub-spawn函数"><a href="#hub-spawn函数" class="headerlink" title="hub.spawn函数"></a><code>hub.spawn</code>函数</h3><p>在Ryu中，<code>hub</code>模块提供了一套基于协程的API。</p><ul><li><code>hub.spawn</code>是Ryu <code>hub</code>模块中的一个函数，用于启动一个新的协程。</li><li>它接受一个可调用对象（如函数或方法）作为参数，并且立即返回。这个可调用对象随后在事件循环中异步执行。</li><li>这种方式允许Ryu应用同时进行多个任务，而不会相互阻塞。这对于需要监听或处理网络事件、定时任务等场景非常有用。</li></ul><h2 id="监测交换机端口变化"><a href="#监测交换机端口变化" class="headerlink" title="监测交换机端口变化"></a>监测交换机端口变化</h2><p>这段代码定义了一个Ryu应用程序<code>PortStatusHandler</code>，它的功能是监听网络中OpenFlow交换机端口状态的变化，并打印出有关这些变化的详细信息。运行这段代码时，我同样模拟链路的迁移过程，可以清晰地观察到各种<code>EventOFPPortStatus</code>事件，说明网络拓扑的变化Ryu都可以精准地捕捉到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ryu.base <span class="keyword">import</span> app_manager</span><br><span class="line"><span class="keyword">from</span> ryu.controller <span class="keyword">import</span> ofp_event</span><br><span class="line"><span class="keyword">from</span> ryu.controller.handler <span class="keyword">import</span> MAIN_DISPATCHER, set_ev_cls</span><br><span class="line"><span class="keyword">from</span> ryu.ofproto <span class="keyword">import</span> ofproto_v1_3</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PortStatusHandler</span>(app_manager.RyuApp):</span><br><span class="line">    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(PortStatusHandler, <span class="variable language_">self</span>).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">ofp_event.EventOFPPortStatus, MAIN_DISPATCHER</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">port_status_handler</span>(<span class="params">self, ev</span>):</span><br><span class="line">        msg = ev.msg</span><br><span class="line">        dp = msg.datapath</span><br><span class="line">        ofp = dp.ofproto</span><br><span class="line">        ofp_parser = dp.ofproto_parser</span><br><span class="line"></span><br><span class="line">        reason = msg.reason</span><br><span class="line">        port_no = msg.desc.port_no</span><br><span class="line">        dpid = dp.<span class="built_in">id</span></span><br><span class="line">        port_name = msg.desc.name</span><br><span class="line"></span><br><span class="line">        reason_str = <span class="string">&#x27;UNKNOWN&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> reason == ofp.OFPPR_ADD:</span><br><span class="line">            reason_str = <span class="string">&#x27;ADD&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> reason == ofp.OFPPR_DELETE:</span><br><span class="line">            reason_str = <span class="string">&#x27;DELETE&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> reason == ofp.OFPPR_MODIFY:</span><br><span class="line">            reason_str = <span class="string">&#x27;MODIFY&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Port status changed in switch DPID=%s (%s): port_no=%s, port_name=%s, reason=%s&quot;</span>, </span><br><span class="line">                         dpid, dp.address, port_no, port_name, reason_str)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检测并更新完整拓扑结构"><a href="#检测并更新完整拓扑结构" class="headerlink" title="检测并更新完整拓扑结构"></a>检测并更新完整拓扑结构</h2><p>这个代码是为了解决<code>from ryu.topology.api import get_link</code>这个方法反应迟缓的问题：可能因为Ryu设定每隔一段时间才会发送LLDP报文，也可能因为Ryu对<code>EventPortAdd</code>不触发网络更新（实验中显示对<code>EventPortDelete</code>很敏感）。</p><p>我计划在自定义 Ryu 应用中使用自带的 switches.py，利用它提供的网络拓扑发现和管理功能，维护一个网络拓扑结构，每当拓扑发生变化时（包括switch.py检测到PortStatus或者Host变化），就更新并打印网络拓扑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ryu.base <span class="keyword">import</span> app_manager</span><br><span class="line"><span class="keyword">from</span> ryu.topology.switches <span class="keyword">import</span> Switches</span><br><span class="line"><span class="keyword">from</span> ryu.controller.handler <span class="keyword">import</span> set_ev_cls</span><br><span class="line"><span class="keyword">from</span> ryu.topology <span class="keyword">import</span> event</span><br><span class="line"><span class="keyword">from</span> ryu.topology.api <span class="keyword">import</span> get_switch, get_link, get_host</span><br><span class="line"><span class="keyword">from</span> ryu.app.simple_switch_13 <span class="keyword">import</span> SimpleSwitch13</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomApp</span>(app_manager.RyuApp):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyCustomApp, <span class="variable language_">self</span>).__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 创建 Switches 实例以使用其功能</span></span><br><span class="line">        <span class="variable language_">self</span>.switches_app = Switches(*args, **kwargs)</span><br><span class="line">        <span class="comment">#self.simple_switch13 = SimpleSwitch13(*args, **kwargs)</span></span><br><span class="line">        <span class="variable language_">self</span>.topology_data = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventSwitchEnter</span>)</span></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventSwitchLeave</span>)</span></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventPortAdd</span>)</span></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventPortDelete</span>)</span></span><br><span class="line">    <span class="comment">#@set_ev_cls(event.EventPortModify)</span></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventLinkAdd</span>)</span></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventLinkDelete</span>)</span></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventHostAdd</span>)</span></span><br><span class="line"><span class="meta">    @set_ev_cls(<span class="params">event.EventHostMove</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topology_change_handler</span>(<span class="params">self, ev</span>):</span><br><span class="line">        <span class="comment"># Update topology data</span></span><br><span class="line">        <span class="variable language_">self</span>.topology_data[<span class="string">&#x27;switches&#x27;</span>] = [switch.to_dict() <span class="keyword">for</span> switch <span class="keyword">in</span> get_switch(<span class="variable language_">self</span>, <span class="literal">None</span>)]</span><br><span class="line">        <span class="variable language_">self</span>.topology_data[<span class="string">&#x27;links&#x27;</span>] = [link.to_dict() <span class="keyword">for</span> link <span class="keyword">in</span> get_link(<span class="variable language_">self</span>, <span class="literal">None</span>)]</span><br><span class="line">        <span class="variable language_">self</span>.topology_data[<span class="string">&#x27;hosts&#x27;</span>] = [host.to_dict() <span class="keyword">for</span> host <span class="keyword">in</span> get_host(<span class="variable language_">self</span>, <span class="literal">None</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Print updated topology</span></span><br><span class="line">        <span class="variable language_">self</span>._print_topology()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_print_topology</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Current Network Topology:&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Switches: %s&quot;</span>, <span class="variable language_">self</span>.topology_data[<span class="string">&#x27;switches&#x27;</span>])</span><br><span class="line">        <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Links: %s&quot;</span>, <span class="variable language_">self</span>.topology_data[<span class="string">&#x27;links&#x27;</span>])</span><br><span class="line">        <span class="variable language_">self</span>.logger.info(<span class="string">&quot;Hosts: %s&quot;</span>, <span class="variable language_">self</span>.topology_data[<span class="string">&#x27;hosts&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充：启动Ryu模块的方式为<code>ryu-manager --observe-links /root/ryu/ryu/app/simple_forward.py ryu.topology.switches</code></p><p><img src="https://typora-kc.oss-cn-chengdu.aliyuncs.com/image/image-20240331004305819.png" alt="topoinfo"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍了如何使用SDN控制器Ryu进行动态网络拓扑的发现和监控。&lt;/p&gt;
&lt;p&gt;通过实现一个名为&lt;code&gt;SimpleTopologyPrinter&lt;/code&gt;的应用，展示了监控网络拓扑变化的基本方法，包括如何捕捉链路的添加和删除事件。实验中修改OvS交换机间的链路，观察到了Ryu对这些变化的响应，发现了链路添加事件有时会延迟反映的问题。本文还解释了Ryu的&lt;code&gt;hub.spawn&lt;/code&gt;函数及其基于协程的并发特性，这些特性允许应用高效地处理多任务。最后，通过构建一个自定义应用，展示了如何利用Ryu维护和更新网络拓扑结构，确保拓扑信息的实时准确全面。本文为学习Openflow协议和Ryu编写规范提供了实用的经验和示例。&lt;/p&gt;</summary>
    
    
    
    <category term="学习印记" scheme="https://keyc.top/categories/%E5%AD%A6%E4%B9%A0%E5%8D%B0%E8%AE%B0/"/>
    
    
    <category term="网络" scheme="https://keyc.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="SDN" scheme="https://keyc.top/tags/SDN/"/>
    
    <category term="Ryu" scheme="https://keyc.top/tags/Ryu/"/>
    
  </entry>
  
</feed>
